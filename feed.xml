<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://hanabzu.github.io/jekyll-theme-yat/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hanabzu.github.io/jekyll-theme-yat/" rel="alternate" type="text/html" /><updated>2023-06-07T09:40:56+00:00</updated><id>https://hanabzu.github.io/jekyll-theme-yat/feed.xml</id><title type="html">soom.log</title><subtitle>hanabzu Github Blog</subtitle><author><name>Lee su-min</name></author><entry><title type="html">[Swift] 비동기 프로그래밍이란</title><link href="https://hanabzu.github.io/jekyll-theme-yat/2023/04/22/Swift-%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%EC%9D%B4%ED%95%B4" rel="alternate" type="text/html" title="[Swift] 비동기 프로그래밍이란" /><published>2023-04-22T00:00:00+00:00</published><updated>2023-04-22T00:00:00+00:00</updated><id>https://hanabzu.github.io/jekyll-theme-yat/2023/04/22/Swift-%EB%B9%84%EB%8F%99%EA%B8%B0%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98%20%EC%9D%B4%ED%95%B4</id><content type="html" xml:base="https://hanabzu.github.io/jekyll-theme-yat/2023/04/22/Swift-%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%EC%9D%B4%ED%95%B4"><![CDATA[<h2 id="1-동기-비동기-개념에-대한-이해">1. 동기/ 비동기 개념에 대한 이해</h2>

<h3 id="쓰레드">쓰레드</h3>

<p>연산을 수행하는 연산 장치 ( 코어 하나당 대부분 2개의 쓰레드 )</p>

<ul>
  <li>소프트웨어적인 Thread - NSThread라고 불리는 객체임</li>
  <li>메인쓰레드 (1번 쓰레드)는 앱의 시작과 화면을 다시 그리는 역할도 한다 (60Hz 1초에 60번)
    <ul>
      <li>여러 역할을 수행하므로 너무 오래 걸리는 작업 시키면 x</li>
      <li>다른 thread로 분산처리를 해야함!</li>
    </ul>
  </li>
</ul>

<aside>
💡 작업(Task)를 대기 행렬(Queue)로 보내기만 하면, iOS가 알아서 여러 쓰레드로 나눠서 분산처리

</aside>

<h3 id="병렬-vs-동시">병렬 vs 동시</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">병렬</code>은 <code class="language-plaintext highlighter-rouge">물리</code>적인 쓰레드에서 실제 동시에 일을 하는 개념이고</li>
  <li><code class="language-plaintext highlighter-rouge">동시성</code>은 메인 쓰레드가 아닌 다른 <code class="language-plaintext highlighter-rouge">소프트웨어</code>적인 쓰레드에서 동시에 일을 하는 개념이다!</li>
</ul>

<p>개발자는 동시성 부분은 신경쓰면 된다.</p>

<p>여러 개의 쓰레드에서 작업을 해도 내부 물리적인 쓰레드는 1개만 사용할 수도 있음</p>

<h2 id="2-비동기-처리가-필요한-이유">2. 비동기 처리가 필요한 이유</h2>

<ul>
  <li>네트워크 통신 - 서버에 데이터 (이미지 등) 를 요청하는 일을 부하가 많이 걸리고 시간이 오래 걸림!</li>
  <li>비동기 처리를 하지 않으면 → 네트워크 통신과 같은 실행이 제대로 동작하지 않아 화면이 버벅거림</li>
  <li>비동기 처리와 동시성 프로그래밍 → <code class="language-plaintext highlighter-rouge">성능/ 반응성/ 최적화</code>와 관련되어 있다!</li>
</ul>

<hr />

<h2 id="3-비동기-동기의-개념">3. 비동기, 동기의 개념</h2>

<h3 id="동기-처리-synchronous">동기 처리 (Synchronous)</h3>

<aside>
💡 작업을 다른 쓰레드에서 하도록 시킨 후, 그 작업이 끝날 때까지 `기다린다`

</aside>

<ul>
  <li>하나의 작업을 마칠 때까지 다음 작업들이 대기하는 것</li>
  <li>서버에 요청을 보냈을 때 응답이 돌아올 때까지 다른 작업들을 멈추고 대기</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">task1</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Task 1 시작"</span><span class="p">)</span>
    <span class="nf">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Task 1 완료★"</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">task2</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Task 2 시작"</span><span class="p">)</span>
    <span class="nf">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Task 2 완료★"</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">task3</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Task 3 시작"</span><span class="p">)</span>
    <span class="nf">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Task 3 완료★"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">task1</span><span class="p">()</span>
<span class="nf">task2</span><span class="p">()</span>
<span class="nf">task3</span><span class="p">()</span>
<span class="c1">// 각자의 task가 수행이 완료되어야만 다음 줄의 함수를 실행한다!</span>
</code></pre></div></div>

<h3 id="비동기-처리-asynchronous">비동기 처리 (Asynchronous)</h3>

<aside>
💡 작업을 다른 쓰레드에서 하도록 시킨 후, 그 작업이 끝나길 `안 기다리고 다른 작업을 수행한다`

</aside>

<ul>
  <li>여러 개의 쓰레드에서 각자 작업들을 수행한다.</li>
  <li>서버에 요청을 보내고 응답이 돌아오기 전에도 다른 작업들을 수행할 수 있음</li>
  <li>일을 시작 시키고, 작업이 끝날 때까지 기다리지 않는다 !!</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">task4</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">DispatchQueue</span><span class="o">.</span><span class="nf">global</span><span class="p">()</span><span class="o">.</span><span class="k">async</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Task 4 시작"</span><span class="p">)</span>
        <span class="nf">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Task 4 완료★"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">task5</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">DispatchQueue</span><span class="o">.</span><span class="nf">global</span><span class="p">()</span><span class="o">.</span><span class="k">async</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Task 5 시작"</span><span class="p">)</span>
        <span class="nf">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Task 5 완료★"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">task6</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">DispatchQueue</span><span class="o">.</span><span class="nf">global</span><span class="p">()</span><span class="o">.</span><span class="k">async</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Task 6 시작"</span><span class="p">)</span>
        <span class="nf">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Task 6 완료★"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">task4</span><span class="p">()</span>
<span class="nf">task5</span><span class="p">()</span>
<span class="nf">task6</span><span class="p">()</span>
<span class="c1">// 동시 다발적으로 queue에서 여러 개의 쓰레드로 보냄 -&gt; 일이 끝나지 않아도 다음 줄 수행</span>
<span class="c1">// (기다리지 않는다!)</span>

<span class="c1">// 출력:</span>
<span class="c1">// Task 6 시작</span>
<span class="c1">// Task 4 시작</span>
<span class="c1">// Task 5 시작</span>
<span class="c1">// 2초 쉬고,</span>
<span class="c1">// Task 5 완료★</span>
<span class="c1">// Task 4 완료★</span>
<span class="c1">// Task 6 완료★</span>
<span class="c1">// -&gt; 각자 다른 쓰레드에서 수행되므로 순서도 바뀐다</span>
</code></pre></div></div>

<h3 id="직렬serial-vs-동시concurrent">직렬(serial) vs 동시(concurrent)</h3>

<ul>
  <li>큐가 thread를 처리하는 방식</li>
  <li>직렬은 한 개의 쓰레드에서 처리한다</li>
  <li>동시는 서로 다른 여러 개의 쓰레드에서 처리한다</li>
</ul>

<h3 id="직렬큐가-필요한-이유">직렬큐가 필요한 이유?</h3>

<p>→ 순서가 중요한 작업을 처리할 때 사용한다</p>

<p>→ 동시성 프로그래밍의 문제를 해결할 때 사용한다</p>

<hr />

<h2 id="4-gcd의-개념-및-종류">4. GCD의 개념 및 종류</h2>

<h3 id="큐의-종류">큐의 종류</h3>

<p>Queue : 작업들을 여러 쓰레드로 보내 분산처리한다@</p>

<ul>
  <li>직접적으로 쓰레드를 관리하지 않고 큐로 보내 작업은 분산처리 한다.</li>
  <li>OS가 알아서 쓰레드 개수 관리
    <ol>
      <li>DispatchQueue ( GCD - Grand Central DispatchQueue)</li>
    </ol>
    <ul>
      <li>(글로벌) 메인 큐 <code class="language-plaintext highlighter-rouge">DispatchQueue.main</code></li>
      <li>글로벌 큐 <code class="language-plaintext highlighter-rouge">DispatchQueue.global()</code></li>
      <li>프라이빗 큐 (커스텀 큐) <code class="language-plaintext highlighter-rouge">DispatchQueue(label:"...")</code>
        <ol>
          <li>OpeationQueue</li>
        </ol>
      </li>
      <li>메인 큐 <code class="language-plaintext highlighter-rouge">OperationQueue.main</code></li>
      <li>프리이빗 큐 (커스텀 큐) <code class="language-plaintext highlighter-rouge">OperationQueue()</code></li>
    </ul>
  </li>
</ul>

<p>1) 메인 큐</p>

<ul>
  <li>메인쓰레드 == 메인 큐</li>
  <li>유일하게 한 개이고, Serial 큐!</li>
  <li>실제로 그냥 메인 쓰레드 (1번 쓰레드)임</li>
  <li>별도의 코드를 작성하지 않으면 모든 작업은 메인 큐에서</li>
</ul>

<p>2) 글로벌 큐 &amp; Qos</p>

<ul>
  <li>종류가 여러 개이고, Concurrent 큐이다!</li>
  <li>
    <p>Qos (Quality of Service)는 6개의 종류가 있다</p>
  </li>
  <li>Qos의 개념
    <ul>
      <li>iOS가 업무의 중요도에 따라 우선순위를 매겨서 더 많은 쓰레드를 배치하고, CPU의 배터리 집중해서 일을 빨리 끝내도록 함</li>
    </ul>
  </li>
</ul>

<p>3) 프리이빗(커스텀) 큐</p>

<ul>
  <li>커스텀으로 개발자가 직접 만드는 큐</li>
  <li>Serial Queue (기본 설정) Concurrent도 가능</li>
  <li>Qos도 설정 가능!</li>
</ul>

<hr />

<h2 id="5-gcd-사용-시-주의해야-할-사항">5. GCD 사용 시 주의해야 할 사항</h2>

<p>1) UI 업데이트는 메인 쓰레드에서 이뤄져야 된다!!!!</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTask</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span> <span class="k">in</span>
    
    <span class="k">if</span> <span class="n">error</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"에러있음"</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">imageData</span> <span class="o">=</span> <span class="n">data</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
    
    <span class="c1">// 즉, 데이터를 가지고 이미지로 변형하는 코드</span>
    <span class="k">let</span> <span class="nv">photoImage</span> <span class="o">=</span> <span class="kt">UIImage</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="n">imageData</span><span class="p">)</span>
    
    <span class="c1">// 🎾 이미지 표시는 DispatchQueue.main에서 🎾</span>
    <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="k">async</span> <span class="p">{</span>
        <span class="n">imageView</span><span class="p">?</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">photoImage</span>
    <span class="p">}</span>
    
    
<span class="p">}</span><span class="o">.</span><span class="nf">resume</span><span class="p">()</span>
</code></pre></div></div>

<p>2) 올바른 비동기 함수의 설계! - 컴플리션 핸들러 (콜백함수) 사용</p>

<ul>
  <li>네트워크 통신 비동기 프로그래밍시 → 함수 return 형식 x 클로저 형식</li>
  <li>다른 쓰레드로 작업을 시키기 때문에 메인 쓰레드 그 작업이 끝나는 시점을 알 수 없음!</li>
  <li>→ 끝나는 시점에 completion 함수 실행 (파라미터가 클로저)</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">getImages</span><span class="p">(</span><span class="n">with</span> <span class="nv">urlString</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UIImage</span><span class="p">?</span> <span class="p">{</span>
    
    <span class="k">let</span> <span class="nv">url</span> <span class="o">=</span> <span class="kt">URL</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="n">urlString</span><span class="p">)</span><span class="o">!</span>
    
    <span class="k">var</span> <span class="nv">photoImage</span><span class="p">:</span> <span class="kt">UIImage</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span>
    
    <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTask</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span> <span class="k">in</span>
        <span class="k">if</span> <span class="n">error</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"에러있음: </span><span class="se">\(</span><span class="n">error</span><span class="o">!</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c1">// 옵셔널 바인딩</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">imageData</span> <span class="o">=</span> <span class="n">data</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        
        <span class="c1">// 데이터를 UIImage 타입으로 변형</span>
        <span class="n">photoImage</span> <span class="o">=</span> <span class="kt">UIImage</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="n">imageData</span><span class="p">)</span>
        
    <span class="p">}</span><span class="o">.</span><span class="nf">resume</span><span class="p">()</span>

    
    <span class="k">return</span> <span class="n">photoImage</span>    <span class="c1">// 항상 nil 이 나옴</span>
<span class="p">}</span>

<span class="nf">getImages</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="s">"https://bit.ly/32ps0DI"</span><span class="p">)</span>    <span class="c1">// 무조건 nil로 리턴함 ⭐️</span>

<span class="o">**********</span> <span class="n">콜백함수</span> <span class="n">활용</span> <span class="o">**********</span>

<span class="kd">func</span> <span class="nf">properlyGetImages</span><span class="p">(</span><span class="n">with</span> <span class="nv">urlString</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">completionHandler</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="kt">UIImage</span><span class="p">?)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="k">let</span> <span class="nv">url</span> <span class="o">=</span> <span class="kt">URL</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="n">urlString</span><span class="p">)</span><span class="o">!</span>
    
    <span class="k">var</span> <span class="nv">photoImage</span><span class="p">:</span> <span class="kt">UIImage</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span>
    
    <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTask</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span> <span class="k">in</span>
        <span class="k">if</span> <span class="n">error</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"에러있음: </span><span class="se">\(</span><span class="n">error</span><span class="o">!</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c1">// 옵셔널 바인딩</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">imageData</span> <span class="o">=</span> <span class="n">data</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        
        <span class="c1">// 데이터를 UIImage 타입으로 변형</span>
        <span class="n">photoImage</span> <span class="o">=</span> <span class="kt">UIImage</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="n">imageData</span><span class="p">)</span>
        
        <span class="nf">completionHandler</span><span class="p">(</span><span class="n">photoImage</span><span class="p">)</span>
        
    <span class="p">}</span><span class="o">.</span><span class="nf">resume</span><span class="p">()</span>
    
<span class="p">}</span>

<span class="c1">// 올바르게 설계한 함수 실행</span>
<span class="nf">properlyGetImages</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="s">"https://bit.ly/32ps0DI"</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="k">in</span>
    
    <span class="c1">// 처리 관련 코드 넣는 곳...</span>
    
    <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="k">async</span> <span class="p">{</span>
        <span class="c1">// UI관련작업의 처리는 여기서</span>
    <span class="p">}</span>
    
<span class="p">}</span>
</code></pre></div></div>

<p>3) weak, strong 사용 시 주의</p>

<p>[객체 내에서 비동기 코드 사용시 주의!]</p>

<ul>
  <li>강한 참조
    <ul>
      <li>클로저 내부에서 객체의 <code class="language-plaintext highlighter-rouge">self</code>사용 시 강한 참조가 된다</li>
      <li>클로저의 수명 주기가 길어짐</li>
    </ul>
  </li>
  <li>약한 참조
    <ul>
      <li>weak self 로 선언하는 것 권장 (일반적인 경우)</li>
      <li>불필요한 일을 줄인다</li>
    </ul>
  </li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 강한 참조 예시</span>
<span class="kd">class</span> <span class="kt">ViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
    
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"뷰컨"</span>
    
    <span class="kd">func</span> <span class="nf">doSomething</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">DispatchQueue</span><span class="o">.</span><span class="nf">global</span><span class="p">()</span><span class="o">.</span><span class="k">async</span> <span class="p">{</span>
            <span class="nf">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"글로벌큐에서 출력하기: </span><span class="se">\(</span><span class="k">self</span><span class="o">.</span><span class="n">name</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kd">deinit</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">name</span><span class="se">)</span><span class="s"> 메모리 해제"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">localScopeFunction</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">vc</span> <span class="o">=</span> <span class="kt">ViewController</span><span class="p">()</span>
    <span class="n">vc</span><span class="o">.</span><span class="nf">doSomething</span><span class="p">()</span>
<span class="p">}</span>
<span class="c1">// 글로벌큐에서 출력하기: 뷰컨</span>
<span class="c1">// 뷰컨 메모리 해제</span>

<span class="c1">// localScopeFunction()은 이미 종료가 되어서 vc가 사라졌지만,</span>
<span class="c1">// 클로저가 vc를 3초동안 붙잡아둠 (강한 참조) RC 증가</span>

<span class="c1">// 약한 참조 예시 (weak self 사용)</span>
<span class="kd">class</span> <span class="kt">ViewController1</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
    
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"뷰컨"</span>
    
    <span class="kd">func</span> <span class="nf">doSomething</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 강한 참조 사이클이 일어나지 않지만, 굳이 뷰컨트롤러를 길게 잡아둘 필요가 없다면</span>
        <span class="c1">// weak self로 선언</span>
        <span class="kt">DispatchQueue</span><span class="o">.</span><span class="nf">global</span><span class="p">()</span><span class="o">.</span><span class="k">async</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="k">in</span>
             <span class="k">guard</span> <span class="k">let</span> <span class="nv">weakSelf</span> <span class="o">=</span> <span class="k">self</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
            <span class="nf">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"글로벌큐에서 출력하기: </span><span class="se">\(</span><span class="n">weakSelf</span><span class="o">.</span><span class="n">name</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kd">deinit</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">name</span><span class="se">)</span><span class="s"> 메모리 해제"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">localScopeFunction1</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">vc</span> <span class="o">=</span> <span class="kt">ViewController1</span><span class="p">()</span>
    <span class="n">vc</span><span class="o">.</span><span class="nf">doSomething</span><span class="p">()</span>
<span class="p">}</span>
<span class="c1">// 뷰컨 메모리 해제</span>
<span class="c1">// 글로벌큐에서 출력하기: nil</span>

<span class="c1">// </span>
<span class="c1">// self가 없어졌으므로 self에 nil값이 들어가있음!</span>
</code></pre></div></div>

<p>4) 동기함수를 비동기적으로 동작하는 함수로 변형하는 방법</p>

<ul>
  <li>일반 (동기) 함수 : 오래 걸리는 일반적인 함수를 단순히 동기 함수로 만들면 메인쓰레드에 부하</li>
  <li>비동기 함수 : 오래 걸리는 일반적인 함수를 내부에 비동기적 처리를 통해 비동기로 동작하는 함수로 변형 가능</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 오래 걸리는 함수!</span>
<span class="kd">func</span> <span class="nf">doSomething</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">print</span><span class="p">(</span><span class="s">"프린트 시작"</span><span class="p">)</span>
	<span class="nf">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
	<span class="nf">print</span><span class="p">(</span><span class="s">"프린트 종료"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">doSomething</span><span class="p">()</span>

<span class="c1">// 비동기로 동작하도록 변형</span>
<span class="kd">func</span> <span class="nf">doSomething</span><span class="p">(</span><span class="nv">completion</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="kt">Void</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">DispatchQueue</span><span class="o">.</span><span class="nf">gloabl</span><span class="p">()</span><span class="o">.</span><span class="k">async</span> <span class="p">{</span>
		<span class="nf">print</span><span class="p">(</span><span class="s">"프린트 시작"</span><span class="p">)</span>
		<span class="nf">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
		<span class="nf">print</span><span class="p">(</span><span class="s">"프린트 종료"</span><span class="p">)</span>
		<span class="nf">completion</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">doSomething</span> <span class="p">{</span>
	<span class="nf">print</span><span class="p">(</span><span class="s">"비동기 동작으로"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="6-비동기-함수메서드의-이해">6. 비동기 함수/메서드의 이해</h2>

<ul>
  <li>애플은 일반적으로 대부분의 오래 걸리는 API들을 내부적으로 비동기적으로 구현해놓음</li>
  <li>URLSession.shared.dataTask 수행 시 → 무조건 다른 Thread로 보내서 일처리 (기다리지 않음)</li>
  <li>이미 내부적으로 GCD를 이용해서, 비동기적으로 처리하는 메서드(함수)</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="s">"출력 - 1"</span><span class="p">)</span>

<span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTask</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span> <span class="k">in</span>
    <span class="k">if</span> <span class="n">error</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">error</span><span class="o">!</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">safeData</span> <span class="o">=</span> <span class="n">data</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    
    <span class="nf">print</span><span class="p">(</span><span class="kt">String</span><span class="p">(</span><span class="nv">decoding</span><span class="p">:</span> <span class="n">safeData</span><span class="p">,</span> <span class="nv">as</span><span class="p">:</span> <span class="kt">UTF8</span><span class="o">.</span><span class="k">self</span><span class="p">))</span>
    
<span class="p">}</span><span class="o">.</span><span class="nf">resume</span><span class="p">()</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"출력 - 2"</span><span class="p">)</span>

<span class="c1">// 출력 결과</span>
<span class="c1">// 출력 - 1</span>
<span class="c1">// 출력 - 2</span>
<span class="c1">// 데이터들~~~</span>
</code></pre></div></div>

<hr />

<h2 id="7-asyncwait의-도입-swift-55">7. Async/wait의 도입 (Swift 5.5~)</h2>

<ul>
  <li>비동기 처리 : 다른 thread로 일을 보내고 수행을 마칠 때까지 기다리지 않고 즉시 리턴!]</li>
  <li>함수 마칠 때 return 형 x 클로저(컴플리션 블럭)을 실행한다</li>
</ul>

<p>💡 클로저 방식 사용 시 단점 !!</p>

<p>completion task가 끝날 때 또 비동기식 작업을 completion task를 실행한다면 ??</p>

<p>비동기 함수가 여러 개 뭉쳐있으면 ??</p>

<p>→  단점 : 끊임없는 콜백함수의 연결, 들여쓰기,,</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">linkedPrint</span><span class="p">(</span><span class="nv">completion</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">longtimePrint</span> <span class="p">{</span> <span class="n">num</span> <span class="k">in</span>
        <span class="c1">// 코드처리</span>
        <span class="n">longtimePrint</span> <span class="p">{</span> <span class="n">num</span> <span class="k">in</span>
            <span class="c1">// 코드처리</span>
            <span class="n">longtimePrint</span> <span class="p">{</span> <span class="n">num</span> <span class="k">in</span>
                <span class="c1">// 코드처리</span>
                <span class="n">longtimePrint</span> <span class="p">{</span> <span class="n">num</span> <span class="k">in</span>
                    <span class="c1">// 코드처리</span>
                    <span class="nf">completion</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>    <span class="c1">// 모든 비동기함수의 종료시점을 알려줌</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<aside>
💡 async/await 키워드 사용해서 리턴 형식으로 바꿔준다

</aside>

<p>async/await 키워드를 붙이면 비동기 작업이 return할 때까지 기다려줘서 리턴 타입을 사용할 수 있게 됨</p>

<p>→ 장점 : 들여쓰지 않고 어디서 코드가 멈추는 지 한눈에 들어온다!</p>

<p>코드가 깔끔해짐~</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">linkedPrint2</span><span class="p">()</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="n">_</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">longtimeAsyncAwait</span><span class="p">()</span>
    <span class="n">_</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">longtimeAsyncAwait</span><span class="p">()</span>
    <span class="n">_</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">longtimeAsyncAwait</span><span class="p">()</span>
    <span class="n">_</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">longtimeAsyncAwait</span><span class="p">()</span>
    <span class="k">return</span> <span class="mi">7</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="8-동시성-프로그래밍과-관련된-문제점">8. 동시성 프로그래밍과 관련된 문제점</h2>

<p>하나의 앱은 코/데/힙/스 영역으로 이루어짐.</p>

<p>대부분의 함수는 stack에 쌓았다 없어지는 구조로 메모리가 움직임!</p>

<p>쓰레드 하나당 Stack 하나 사용 → 각자 쓰레드마다 수행하는 작업과 사용하는 메모리 다름!</p>

<p>코드, 데이터, 힙 영역의 메모리는 공유한다!</p>

<ul>
  <li>메인 쓰레드 stack에 main() 함수</li>
  <li>global등 비동기적 함수는 다른 Stack에서 실행</li>
</ul>

<hr />

<p>1) 경쟁상황/ 경쟁조건 (Race Condition)</p>

<ul>
  <li>= <code class="language-plaintext highlighter-rouge">Thread-safe 하지 않음</code></li>
  <li>멀티 쓰레드 환경에서, 같은 시점에 여러 개의 쓰레드에서 하나의 메모리에 동시 접근하는 문제 발생!</li>
  <li>
    <p>클래스의 인스턴스와 같은 힙 영역의 메모리에 여러 쓰레드가 동시 접근</p>

    <p>(이름을 쓰는 와중에 다른 쓰레드에서 이름을 읽을 경우 ???)</p>
  </li>
  <li>한 쓰레드에 하나만 접근할 수 있도록 Lock을 거는 방식으로 해결 (Thread-Safe 처리)</li>
</ul>

<hr />

<p>2) 교착상태 (Deadlocks)</p>

<ul>
  <li>멀티 쓰레드 환경에서, 베타적인 메모리 사용으로 일이 진행이 안되는 문제</li>
  <li>쓰레드의 작업이 종료되지 않아 앱이 멈추는 상황!</li>
  <li>앱이 여러 개일 경우도 같은 함수를 사용하다 설정이 바뀌면 모든 앱이 중단된다.</li>
</ul>

<hr />

<h2 id="9-동시성-프로그래밍-문제점의-해결">9. 동시성 프로그래밍 문제점의 해결</h2>

<p>⭐️ 동시큐에서 직렬큐로 보내기</p>

<p>여러 쓰레드에서 동시 접근하는 작업은 다시 Serial Queue로 보낸다</p>

<p>→ 순차적인 처리 가능 &amp; 하나의 쓰레드에서만 메모리에 접근</p>]]></content><author><name>Lee su-min</name></author><category term="Swift" /><category term="비동기 프로그래밍" /><category term="쓰레드" /><category term="큐" /><category term="작업" /><summary type="html"><![CDATA[1. 동기/ 비동기 개념에 대한 이해]]></summary></entry><entry><title type="html">[알고리즘/Swift] 과제 진행하기</title><link href="https://hanabzu.github.io/jekyll-theme-yat/2023/04/12/Programmers-%EA%B3%BC%EC%A0%9C-%EC%A7%84%ED%96%89%ED%95%98%EA%B8%B0" rel="alternate" type="text/html" title="[알고리즘/Swift] 과제 진행하기" /><published>2023-04-12T00:00:00+00:00</published><updated>2023-04-12T00:00:00+00:00</updated><id>https://hanabzu.github.io/jekyll-theme-yat/2023/04/12/Programmers-%EA%B3%BC%EC%A0%9C%20%EC%A7%84%ED%96%89%ED%95%98%EA%B8%B0</id><content type="html" xml:base="https://hanabzu.github.io/jekyll-theme-yat/2023/04/12/Programmers-%EA%B3%BC%EC%A0%9C-%EC%A7%84%ED%96%89%ED%95%98%EA%B8%B0"><![CDATA[<h2 id="문제">문제</h2>
<p>과제를 받은 루는 다음과 같은 순서대로 과제를 하려고 계획을 세웠습니다.</p>

<p>과제는 시작하기로 한 시각이 되면 시작합니다.<br />
새로운 과제를 시작할 시각이 되었을 때, 기존에 진행 중이던 과제가 있다면 진행 중이던 과제를 멈추고 새로운 과제를 시작합니다.<br />
진행중이던 과제를 끝냈을 때, 잠시 멈춘 과제가 있다면, 멈춰둔 과제를 이어서 진행합니다.<br />
만약, 과제를 끝낸 시각에 새로 시작해야 되는 과제와 잠시 멈춰둔 과제가 모두 있다면, 새로 시작해야 하는 과제부터 진행합니다.<br />
멈춰둔 과제가 여러 개일 경우, 가장 최근에 멈춘 과제부터 시작합니다.<br />
과제 계획을 담은 이차원 문자열 배열 plans가 매개변수로 주어질 때, 과제를 끝낸 순서대로 이름을 배열에 담아 return 하는 solution 함수를 완성해주세요.</p>

<h3 id="제한-사항">제한 사항</h3>
<p>3 ≤ plans의 길이 ≤ 1,000<br />
plans의 원소는 [name, start, playtime]의 구조로 이루어져 있습니다.<br />
name : 과제의 이름을 의미합니다.<br />
2 ≤ name의 길이 ≤ 10<br />
name은 알파벳 소문자로만 이루어져 있습니다.<br />
name이 중복되는 원소는 없습니다.<br />
start : 과제의 시작 시각을 나타냅니다.<br />
“hh:mm”의 형태로 “00:00” ~ “23:59” 사이의 시간값만 들어가 있습니다.<br />
모든 과제의 시작 시각은 달라서 겹칠 일이 없습니다.<br />
과제는 “00:00” … “23:59” 순으로 시작하면 됩니다. 즉, 시와 분의 값이 작을수록 더 빨리 시작한 과제입니다.<br />
playtime : 과제를 마치는데 걸리는 시간을 의미하며, 단위는 분입니다.<br />
1 ≤ playtime ≤ 100<br />
playtime은 0으로 시작하지 않습니다.<br />
배열은 시간순으로 정렬되어 있지 않을 수 있습니다. <br />
진행중이던 과제가 끝나는 시각과 새로운 과제를 시작해야하는 시각이 같은 경우 진행중이던 과제는 끝난 것으로 판단합니다.</p>

<h3 id="입출력">입출력</h3>

<table>
  <thead>
    <tr>
      <th>plans</th>
      <th>result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[["korean", "11:40", "30"], ["english", "12:10", "20"], ["math", "12:30", "40"]]	["korean", "english", "math"]</td>
      <td>["korean", "english", "math"]</td>
    </tr>
    <tr>
      <td>[["science", "12:40", "50"], ["music", "12:20", "40"], ["history", "14:00", "30"], ["computer", "12:30", "100"]]	["science", "history", "computer", "music"]</td>
      <td>["science", "history", "computer", "music"]</td>
    </tr>
    <tr>
      <td>[["aaa", "12:00", "20"], ["bbb", "12:10", "30"], ["ccc", "12:40", "10"]]	["bbb", "ccc", "aaa"]</td>
      <td>["bbb", "ccc", "aaa"]</td>
    </tr>
  </tbody>
</table>

<hr />
<h2 id="풀이">풀이</h2>
<p>시각을 포맷을 다루는 문제가 처음이라 꽤 많은 시간이 걸렸지만 차근 차근 해결하니 풀 수 있었다. <br />
과제 수행을 완료하지 못한 과제들을 <code class="language-plaintext highlighter-rouge">waitStack</code>에 넣어준 후,  <br />
남은 과제들을 시간이 빌 때마다 <code class="language-plaintext highlighter-rouge">waitstack</code>에 있는 과제들을 <code class="language-plaintext highlighter-rouge">popLast</code>하여 수행해주었다.  <br />
그래도, pop한 과제를 수행을 다 못할 경우에는 남은 <code class="language-plaintext highlighter-rouge">남은 과제 수행 - 틈새 시간</code>을 다시 <code class="language-plaintext highlighter-rouge">waitStack</code>에 <code class="language-plaintext highlighter-rouge">pushLast</code> 해주었다.</p>

<h2 id="나만의-알고리즘">나만의 알고리즘</h2>
<p>시각 포맷 변환 함수들을 먼저 만들고,<br />
입력 받은 과제 리스트들을 과제 시작하는 시각을 오름차순으로 정렬한다.  <br />
그 후, 정렬된 과제 리스트들을 idx 1부터 돌면서 <br />
i번째 과제 시작하는 시각과 (i-1번째 과제 시작하는 시간 + i-1번째 과제하는 시간)의 차를 구해서</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">waitTime</span> <span class="o">=</span> <span class="nf">dateDif</span><span class="p">(</span><span class="n">sortedPlans</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="nf">dateAdd</span><span class="p">(</span><span class="n">sortedPlans</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="kt">Int</span><span class="p">(</span><span class="n">sortedPlans</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">!</span><span class="p">))</span>
</code></pre></div></div>
<p>그 차가 0 이상이면 i-1번째 과제를 완료한 것으로, 0 미만이면 과제를 전부 수행하지 못한 것으로 간주했다.</p>
<ul>
  <li>과제를 완료한 경우에는
    <ul>
      <li><code class="language-plaintext highlighter-rouge">result</code> 배열에 과제명을 넣어주고,</li>
      <li><code class="language-plaintext highlighter-rouge">waitTime &gt; 0</code> 이고 <code class="language-plaintext highlighter-rouge">waitStack 원소가 있을 경우</code>, 그 과제를 수행해주고 과제 수행을 완료할 경우 <code class="language-plaintext highlighter-rouge">waitTime</code>에서 과제 수행하는 데 쓴 시간을 빼고 업데이트 해준다. 또, 수행 완료한 과제를 <code class="language-plaintext highlighter-rouge">result</code> 배열에 넣어준다.</li>
      <li><code class="language-plaintext highlighter-rouge">waitTime</code> 동안에 과제 수행을 완료하지 못할 경우 <code class="language-plaintext highlighter-rouge">waitTime</code>을 다 썼으므로 0으로 초기화 해주고, <code class="language-plaintext highlighter-rouge">waitStack</code>에 과제의 남은 시간을 다시 <code class="language-plaintext highlighter-rouge">pushLast</code>해준다.</li>
    </ul>
  </li>
  <li>과제를 완료하지 못한 경우에는,
    <ul>
      <li><code class="language-plaintext highlighter-rouge">waitStack</code>에 과제명과, <code class="language-plaintext highlighter-rouge">waitTime</code>을 튜플로 함께 넣어준다.</li>
    </ul>
  </li>
  <li>모든 처리를 마친 후, i가 마지막 과제일 경우, 무조건 완료가 되므로 <code class="language-plaintext highlighter-rouge">result</code> 배열에 넣어준다.</li>
  <li>이 후, <code class="language-plaintext highlighter-rouge">waitStack</code>에 남아있는 모든 과제들을 <code class="language-plaintext highlighter-rouge">popLast</code>한 순서대로 완료해준다. (<code class="language-plaintext highlighter-rouge">result</code> 배열에 넣어준다)</li>
</ul>

<p>시간 계산을 하는 함수</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 두 시각을 String으로 입력받아 두 시각의 차를 분으로 Int 값 반환</span>
<span class="kd">func</span> <span class="nf">dateDif</span><span class="p">(</span><span class="n">_</span> <span class="nv">bighhmm</span><span class="p">:</span><span class="kt">String</span><span class="p">,</span> <span class="n">_</span> <span class="nv">hhmm</span><span class="p">:</span><span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="c1">// a[0] = hh, a[1] = mm</span>
    <span class="k">let</span> <span class="nv">a</span> <span class="o">=</span> <span class="n">hhmm</span><span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">":"</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="kt">Int</span><span class="p">(</span><span class="kt">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">))</span><span class="o">!</span><span class="p">}</span>
    <span class="c1">// b[0] = hh, b[1] = mm</span>
    <span class="k">let</span> <span class="nv">b</span> <span class="o">=</span> <span class="n">bighhmm</span><span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">":"</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="kt">Int</span><span class="p">(</span><span class="kt">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">))</span><span class="o">!</span><span class="p">}</span>
    <span class="c1">// 분끼리의 차</span>
    <span class="k">let</span> <span class="nv">min</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">min</span>
    <span class="p">}</span> 
    <span class="c1">// 시각끼리의 차</span>
    <span class="k">let</span> <span class="nv">hour</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1">// 시각끼리의 차와 분끼리의 차를 minute 형태로 변환하여 반환</span>
    <span class="k">return</span> <span class="n">hour</span><span class="o">*</span><span class="mi">60</span> <span class="o">+</span> <span class="n">min</span>
<span class="p">}</span>

<span class="c1">// 입력 받은 시간에 입력 받은 분을 더했을 때의 시간 String 값으로 반환</span>
<span class="kd">func</span> <span class="nf">dateAdd</span><span class="p">(</span><span class="n">_</span> <span class="nv">hhmm</span><span class="p">:</span><span class="kt">String</span><span class="p">,</span> <span class="n">_</span> <span class="nv">add</span><span class="p">:</span><span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">date</span> <span class="o">=</span> <span class="n">hhmm</span><span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">":"</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="kt">Int</span><span class="p">(</span><span class="kt">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">))</span><span class="o">!</span><span class="p">}</span>
    <span class="c1">// 분끼리 더했을 때 60분을 넘을 때</span>
    <span class="k">if</span> <span class="n">date</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">add</span> <span class="o">&lt;</span> <span class="mi">60</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">String</span><span class="p">(</span><span class="n">date</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> <span class="kt">String</span><span class="p">(</span><span class="n">date</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">add</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="nv">hour</span> <span class="o">=</span> <span class="p">(</span><span class="n">date</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">add</span><span class="p">)</span> <span class="o">/</span> <span class="mi">60</span> <span class="o">+</span> <span class="n">date</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">let</span> <span class="nv">min</span> <span class="o">=</span> <span class="p">(</span><span class="n">date</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">add</span><span class="p">)</span> <span class="o">%</span> <span class="mi">60</span>
    <span class="c1">// minute이 0인 경우, mm 형식인 "00"으로 바꿔줘야함.</span>
    <span class="k">if</span> <span class="n">min</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">String</span><span class="p">(</span><span class="n">hour</span><span class="p">)</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> <span class="s">"0"</span> <span class="o">+</span> <span class="kt">String</span><span class="p">(</span><span class="n">min</span><span class="p">)</span> 
    <span class="p">}</span>
    <span class="k">return</span> <span class="kt">String</span><span class="p">(</span><span class="n">hour</span><span class="p">)</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> <span class="kt">String</span><span class="p">(</span><span class="n">min</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="코드">코드</h3>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Foundation</span>
<span class="c1">// 두 시간을 String으로 입력받아 시간 차의 분을 Int 값을 반환</span>
<span class="kd">func</span> <span class="nf">dateDif</span><span class="p">(</span><span class="n">_</span> <span class="nv">bighhmm</span><span class="p">:</span><span class="kt">String</span><span class="p">,</span> <span class="n">_</span> <span class="nv">hhmm</span><span class="p">:</span><span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">a</span> <span class="o">=</span> <span class="n">hhmm</span><span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">":"</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="kt">Int</span><span class="p">(</span><span class="kt">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">))</span><span class="o">!</span><span class="p">}</span>
    <span class="k">let</span> <span class="nv">b</span> <span class="o">=</span> <span class="n">bighhmm</span><span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">":"</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="kt">Int</span><span class="p">(</span><span class="kt">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">))</span><span class="o">!</span><span class="p">}</span>
    <span class="k">let</span> <span class="nv">min</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">min</span>
    <span class="p">}</span> 
    <span class="k">let</span> <span class="nv">hour</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">hour</span><span class="o">*</span><span class="mi">60</span> <span class="o">+</span> <span class="n">min</span>
<span class="p">}</span>
<span class="c1">// 입력 받은 시간에 입력 받은 분을 더했을 때의 시간 String 값으로 반환</span>
<span class="kd">func</span> <span class="nf">dateAdd</span><span class="p">(</span><span class="n">_</span> <span class="nv">hhmm</span><span class="p">:</span><span class="kt">String</span><span class="p">,</span> <span class="n">_</span> <span class="nv">add</span><span class="p">:</span><span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">date</span> <span class="o">=</span> <span class="n">hhmm</span><span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">":"</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="kt">Int</span><span class="p">(</span><span class="kt">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">))</span><span class="o">!</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">date</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">add</span> <span class="o">&lt;</span> <span class="mi">60</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">String</span><span class="p">(</span><span class="n">date</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> <span class="kt">String</span><span class="p">(</span><span class="n">date</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">add</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="nv">hour</span> <span class="o">=</span> <span class="p">(</span><span class="n">date</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">add</span><span class="p">)</span> <span class="o">/</span> <span class="mi">60</span> <span class="o">+</span> <span class="n">date</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">let</span> <span class="nv">min</span> <span class="o">=</span> <span class="p">(</span><span class="n">date</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">add</span><span class="p">)</span> <span class="o">%</span> <span class="mi">60</span>
    <span class="k">if</span> <span class="n">min</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">String</span><span class="p">(</span><span class="n">hour</span><span class="p">)</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> <span class="s">"0"</span> <span class="o">+</span> <span class="kt">String</span><span class="p">(</span><span class="n">min</span><span class="p">)</span> 
    <span class="p">}</span>
    <span class="k">return</span> <span class="kt">String</span><span class="p">(</span><span class="n">hour</span><span class="p">)</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> <span class="kt">String</span><span class="p">(</span><span class="n">min</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">solution</span><span class="p">(</span><span class="n">_</span> <span class="nv">plans</span><span class="p">:[[</span><span class="kt">String</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="nf">dateAdd</span><span class="p">(</span><span class="s">"12:56"</span><span class="p">,</span> <span class="mi">23</span><span class="p">))</span>
    <span class="nf">print</span><span class="p">(</span><span class="nf">dateDif</span><span class="p">(</span><span class="s">"14:28"</span><span class="p">,</span> <span class="s">"11:56"</span><span class="p">))</span>
    <span class="k">var</span> <span class="nv">waitStack</span><span class="p">:</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">var</span> <span class="nv">result</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">// 과제 시작하는 시점으로 오름차순 정렬</span>
    <span class="k">let</span> <span class="nv">sortedPlans</span> <span class="o">=</span> <span class="n">plans</span><span class="o">.</span><span class="n">sorted</span><span class="p">{</span> <span class="p">(</span><span class="nv">$0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">":"</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="nv">$0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">":"</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nv">$1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">":"</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span> <span class="nv">$1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">":"</span><span class="p">)[</span><span class="mi">1</span><span class="p">])}</span>
   
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..&lt;</span><span class="n">plans</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
        <span class="k">var</span> <span class="nv">waitTime</span> <span class="o">=</span> <span class="nf">dateDif</span><span class="p">(</span><span class="n">sortedPlans</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="nf">dateAdd</span><span class="p">(</span><span class="n">sortedPlans</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="kt">Int</span><span class="p">(</span><span class="n">sortedPlans</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">!</span><span class="p">))</span>
        <span class="c1">// 과제를 수행한 경우</span>
        <span class="k">if</span> <span class="n">waitTime</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">result</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">sortedPlans</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">while</span> <span class="n">waitTime</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">waitStack</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span>
                <span class="k">let</span> <span class="nv">assign</span> <span class="o">=</span> <span class="n">waitStack</span><span class="o">.</span><span class="nf">removeLast</span><span class="p">()</span>
                <span class="c1">// 임시 과제를 다 못 끝내는 경우 다시 스택에 넣는다</span>
                <span class="k">if</span> <span class="n">waitTime</span> <span class="o">&lt;</span> <span class="n">assign</span><span class="o">.</span><span class="mi">1</span> <span class="p">{</span>
                    <span class="n">waitStack</span><span class="o">.</span><span class="nf">append</span><span class="p">((</span><span class="n">assign</span><span class="o">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">assign</span><span class="o">.</span><span class="mi">1</span> <span class="o">-</span> <span class="n">waitTime</span><span class="p">))</span>
                    <span class="n">waitTime</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="p">}</span> 
                <span class="c1">// 임시 과제를 다 끝내는 경우, waitTime 갱신해주고 다시 while문</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="n">waitTime</span> <span class="o">=</span> <span class="n">waitTime</span> <span class="o">-</span> <span class="n">assign</span><span class="o">.</span><span class="mi">1</span>
                    <span class="n">result</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">assign</span><span class="o">.</span><span class="mi">0</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 과제를 수행하지 못한 경우</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">waitStack</span><span class="o">.</span><span class="nf">append</span><span class="p">((</span><span class="n">sortedPlans</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nf">abs</span><span class="p">(</span><span class="n">waitTime</span><span class="p">)))</span>
        <span class="p">}</span>
        <span class="c1">// 마지막 과제에 도달할 경우, 무조건 수행한다</span>
         <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">plans</span><span class="o">.</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
           <span class="n">result</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">sortedPlans</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
         <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// waitStack에 남아있는 과제들을 전부 popLast해 result에 넣는다</span>
    <span class="k">while</span> <span class="o">!</span><span class="n">waitStack</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">assign</span> <span class="o">=</span> <span class="n">waitStack</span><span class="o">.</span><span class="nf">removeLast</span><span class="p">()</span><span class="o">.</span><span class="mi">0</span>
        <span class="n">result</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">assign</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Lee su-min</name></author><category term="Algorithm" /><category term="프로그래머스" /><category term="Problem Solving" /><category term="Array" /><category term="구현" /><category term="stack" /><category term="Last-in-First-Out" /><summary type="html"><![CDATA[문제 과제를 받은 루는 다음과 같은 순서대로 과제를 하려고 계획을 세웠습니다.]]></summary></entry><entry><title type="html">[알고리즘/Swift] 연속된 부분 수열의 합</title><link href="https://hanabzu.github.io/jekyll-theme-yat/2023/04/12/Programmers-%EC%97%B0%EC%86%8D%EB%90%9C-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4%EC%9D%98-%ED%95%A9" rel="alternate" type="text/html" title="[알고리즘/Swift] 연속된 부분 수열의 합" /><published>2023-04-12T00:00:00+00:00</published><updated>2023-04-12T00:00:00+00:00</updated><id>https://hanabzu.github.io/jekyll-theme-yat/2023/04/12/Programmers-%EC%97%B0%EC%86%8D%EB%90%9C%20%EB%B6%80%EB%B6%84%20%EC%88%98%EC%97%B4%EC%9D%98%20%ED%95%A9</id><content type="html" xml:base="https://hanabzu.github.io/jekyll-theme-yat/2023/04/12/Programmers-%EC%97%B0%EC%86%8D%EB%90%9C-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4%EC%9D%98-%ED%95%A9"><![CDATA[<h2 id="문제">문제</h2>
<p>비내림차순으로 정렬된 수열이 주어질 때, 다음 조건을 만족하는 부분 수열을 찾으려고 합니다.</p>

<p>기존 수열에서 임의의 두 인덱스의 원소와 그 사이의 원소를 모두 포함하는 부분 수열이어야 합니다.<br />
부분 수열의 합은 k입니다.<br />
합이 k인 부분 수열이 여러 개인 경우 길이가 짧은 수열을 찾습니다.<br />
길이가 짧은 수열이 여러 개인 경우 앞쪽(시작 인덱스가 작은)에 나오는 수열을 찾습니다.<br />
수열을 나타내는 정수 배열 sequence와 부분 수열의 합을 나타내는 정수 k가 매개변수로 주어질 때, 위 조건을 만족하는 부분 수열의 시작 인덱스와 마지막 인덱스를 배열에 담아 return 하는 solution 함수를 완성해주세요. 이때 수열의 인덱스는 0부터 시작합니다.</p>

<h3 id="제한-사항">제한 사항</h3>
<p>5 ≤ sequence의 길이 ≤ 1,000,000<br />
1 ≤ sequence의 원소 ≤ 1,000<br />
sequence는 비내림차순으로 정렬되어 있습니다.<br />
5 ≤ k ≤ 1,000,000,000<br />
k는 항상 sequence의 부분 수열로 만들 수 있는 값입니다.</p>

<h3 id="입출력">입출력</h3>

<table>
  <thead>
    <tr>
      <th>sequence</th>
      <th>k</th>
      <th>result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[1, 2, 3, 4, 5]</td>
      <td>7</td>
      <td>[2, 3]</td>
    </tr>
    <tr>
      <td>[1, 1, 1, 2, 3, 4, 5]</td>
      <td>5</td>
      <td>[6, 6]</td>
    </tr>
    <tr>
      <td>[2, 2, 2, 2, 2]</td>
      <td>6</td>
      <td>[0, 2]</td>
    </tr>
  </tbody>
</table>

<hr />
<h2 id="풀이">풀이</h2>
<p>부분 수열의 최댓값 문제는 많이 풀어봤지만 다양한 조건에 해당하는 값을 찾는 문제는 처음이라 많이 해맸다. <br />
부분 수열의 조건을 정리하면 다음과 같다.</p>
<ul>
  <li>합이 k</li>
  <li>길이가 가장 짧은 수열</li>
  <li>길이가 같다면 가장 앞의 부분 수열</li>
  <li>수열 idx는 0부터</li>
  <li>수열은 모두 오름차순으로 정렬되어 있음</li>
</ul>

<p>일반적인 투 포인터 문제이다. <br />
모든 부분 수열들을 다 살펴줘야 하지만, 오름차순으로 정렬되어 있으므로 두 포인터를 사용하여<br />
sum에 뒤의 추가적인 원소를 더하고 앞의 원소를 빼면 좀 더 효율적인 코드를 짤 수 있을 거라고 판단하였다. <br />
알고리즘은 sum 에 배열의 첫 원소를 넣어주고, start, end 두 포인터를 0으로 초기화한다.<br />
길이가 가장 짧고, 길이가 같다면 가장 앞의 부분 수열을 구해야 하므로, min 변수의 값보다 배열의 길이가 작을 때만 업데이트 해주도록 하였다.<br />
while문을 돌면서</p>
<ul>
  <li>start가 배열을 다 돌 때까지 while을 돌면서</li>
  <li>sum이 k보다 작을 경우,
    <ul>
      <li>end가 배열의 마지막이면, while문을 중단하고,</li>
      <li>마지막이 아닐 경우, end값을 뒤로 한 칸 이동시키고, sum값에 더해준다.</li>
    </ul>
  </li>
  <li>sum이 k보다 클 경우,
    <ul>
      <li>sum에서 start값을 빼주고, sum을 뒤로 한 칸 이동시킨다.</li>
    </ul>
  </li>
  <li>sum == k 일 경우, min값과 비교하여 최소 길이의 정답 부분 수열을 업데이트 해준다.
                이 후, end를 뒤로 한 칸 이동시키고, sum에 더해주는데, end가 마지막 원소일 경우, 연산을 해주지 않는다.</li>
</ul>

<h3 id="코드">코드</h3>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Foundation</span>

<span class="kd">func</span> <span class="nf">solution</span><span class="p">(</span><span class="n">_</span> <span class="nv">sequence</span><span class="p">:[</span><span class="kt">Int</span><span class="p">],</span> <span class="n">_</span> <span class="nv">k</span><span class="p">:</span><span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">min</span> <span class="o">=</span> <span class="n">sequence</span><span class="o">.</span><span class="n">count</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">var</span> <span class="p">(</span><span class="nv">start</span><span class="p">,</span> <span class="nv">end</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">var</span> <span class="nv">result</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">var</span> <span class="nv">sum</span> <span class="o">=</span> <span class="n">sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">sequence</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">sum</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">end</span> <span class="o">==</span> <span class="n">sequence</span><span class="o">.</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="k">break</span>
            <span class="p">}</span>
            <span class="n">end</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">sequence</span><span class="p">[</span><span class="n">end</span><span class="p">]</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="n">k</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">-=</span> <span class="n">sequence</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">min</span> <span class="p">{</span>
                <span class="n">min</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">]</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">end</span> <span class="o">==</span> <span class="n">sequence</span><span class="o">.</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="k">break</span>
            <span class="p">}</span>
            <span class="n">end</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">sequence</span><span class="p">[</span><span class="n">end</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="p">}</span>
   <span class="k">return</span> <span class="n">result</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Lee su-min</name></author><category term="Algorithm" /><category term="프로그래머스" /><category term="Problem Solving" /><category term="Array" /><category term="구현" /><category term="투 포인터" /><category term="배열의 합" /><summary type="html"><![CDATA[문제 비내림차순으로 정렬된 수열이 주어질 때, 다음 조건을 만족하는 부분 수열을 찾으려고 합니다.]]></summary></entry><entry><title type="html">[Swift] self vs Self 비교</title><link href="https://hanabzu.github.io/jekyll-theme-yat/2023/04/11/Swift-selfvsSelf" rel="alternate" type="text/html" title="[Swift] self vs Self 비교" /><published>2023-04-11T00:00:00+00:00</published><updated>2023-04-11T00:00:00+00:00</updated><id>https://hanabzu.github.io/jekyll-theme-yat/2023/04/11/Swift-selfvsSelf</id><content type="html" xml:base="https://hanabzu.github.io/jekyll-theme-yat/2023/04/11/Swift-selfvsSelf"><![CDATA[<h2 id="self와-self-비교">self와 Self 비교</h2>

<p>생성자를 다루면서 자주 사용했었던 self와 간간히 나오는 Self의 차이점을 비교해보겠다</p>
<h3 id="self">self</h3>
<blockquote>
  <p>self는 인스턴스를 가리킨다!!</p>
</blockquote>

<ul>
  <li>self는 자기 자신의 인스턴스를 가리킨다고 한다</li>
  <li>다양한 예시를 보며 self가 쓰이는 경우를 알아보자</li>
</ul>

<ol>
  <li>생성자 내부에서 사용    <br />
클래스 or 구조체의 생성자에서 해당 저장 프로퍼티를 초기화할 경우 <code class="language-plaintext highlighter-rouge">self.저장 프로퍼티</code> 와 같이 self 키워드로 자기 자신의 인스턴스의 저장 프로퍼티에 접근한다</li>
</ol>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Person</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">p</span> <span class="o">=</span> <span class="kt">Person</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span><span class="s">"sumin"</span><span class="p">)</span>
</code></pre></div></div>

<ol>
  <li>클래스 내부에서 저장 프로퍼티에 접근하는 경우 사용</li>
</ol>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Person</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">sayMyName</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="k">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">p</span> <span class="o">=</span> <span class="kt">Person</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span><span class="s">"sumin"</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="nf">sayMyName</span><span class="p">()</span>
<span class="c1">// sumin 출력</span>
</code></pre></div></div>
<p><br />
다음과 같이 p 인스턴스는 <code class="language-plaintext highlighter-rouge">self</code> 키워드를 통해 자기 자신의 인스턴스의 name 저장 프로퍼티를 초기화하고,
함수 내부에서 자기 자신의 인스턴스에 접근하여 해당 프로퍼티를 출력할 수 있다!  <br />
물론 구조체에서는 값 타입으로 함수에서 자기 자신의 프로퍼티에 접근할 수 없으므로 <code class="language-plaintext highlighter-rouge">mutating</code> 키워드를 사용한다</p>

<ol>
  <li>새로운 값으로 프로퍼티 초기화 하는 경우
    <ul>
      <li>값 타입에서는 인스턴스 값 자체를 치환할 수 있다</li>
      <li>인스턴스를 새로 생성하여 치환하는 것도 가능하다</li>
      <li>클래스는 사용 불가능 (클래스는 참조 타입이므로 self 타입 변경 불가능하다)</li>
    </ul>
  </li>
</ol>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Calculator</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">number</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">plusNumber</span><span class="p">(</span><span class="n">_</span> <span class="nv">num</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">number</span> <span class="o">=</span> <span class="n">number</span> <span class="o">+</span> <span class="n">num</span>
    <span class="p">}</span>

    <span class="c1">// 구조체의 메서드 내에서 self 키워드로 인스턴스를 새로 생성하여 치환</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">reset</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span> <span class="o">=</span> <span class="kt">Calculator</span><span class="p">()</span>  
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">c</span> <span class="o">=</span> <span class="kt">Calculator</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="nf">reset</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">number</span><span class="p">)</span> <span class="c1">// 0 출력</span>
</code></pre></div></div>

<ol>
  <li>타입 멤버에서 사용하는 경우, 인스턴스가 아닌 타입 자체를 가르킨다</li>
</ol>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">struct</span> <span class="kt">Dog</span> <span class="p">{</span>
      <span class="kd">static</span> <span class="k">let</span> <span class="nv">species</span> <span class="o">=</span> <span class="s">"강아지"</span>

      <span class="kd">static</span> <span class="kd">func</span> <span class="nf">doPrintSpecies</span><span class="p">()</span> <span class="p">{</span>
          <span class="nf">print</span><span class="p">(</span><span class="s">"종은 </span><span class="se">\(</span><span class="k">self</span><span class="o">.</span><span class="n">species</span><span class="se">)</span><span class="s">입니다."</span><span class="p">)</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">Dog</span><span class="o">.</span><span class="nf">doPrintSpecies</span><span class="p">()</span> <span class="c1">// 종은 강아지입니다. 출력</span>
</code></pre></div></div>
<p>self 키워드가 타입 메서드내에서 해당 인스턴스가 아닌 해당 타입을 가르킨다</p>

<ol>
  <li>타입 인스턴스를 가르키는 경우, 타입 자체의 뒤에 붙여서 사용한다
    <ul>
      <li>외부에서 타입을 가르키는 경우</li>
      <li>타입 인스턴스는 데이터 영역에 저장된다</li>
    </ul>
  </li>
</ol>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">class</span> <span class="kt">SomeClass</span> <span class="p">{</span>
      <span class="kd">static</span> <span class="k">let</span> <span class="nv">name</span> <span class="o">=</span> <span class="s">"클래스"</span>
  <span class="p">}</span>


  <span class="k">let</span> <span class="nv">myClass</span><span class="p">:</span> <span class="kt">SomeClass</span><span class="o">.</span><span class="k">Type</span> <span class="o">=</span> <span class="kt">SomeClass</span><span class="o">.</span><span class="k">self</span>
  <span class="n">myClass</span><span class="o">.</span><span class="n">name</span>

  <span class="kt">SomeClass</span><span class="o">.</span><span class="n">name</span> <span class="c1">//  "클래스"</span>
  <span class="kt">SomeClass</span><span class="o">.</span><span class="k">self</span><span class="o">.</span><span class="n">name</span> <span class="c1">//  "클래스"</span>

  <span class="kt">Int</span><span class="o">.</span><span class="n">max</span> <span class="c1">// 9223372036854775807</span>
  <span class="kt">Int</span><span class="o">.</span><span class="k">self</span><span class="o">.</span><span class="n">max</span> <span class="c1">// 9223372036854775807 </span>
</code></pre></div></div>

<h3 id="self-1">Self</h3>
<blockquote>
  <p>Self는 타입을 가르킨다!</p>
</blockquote>

<ol>
  <li>특정 타입 내부에서 타입을 선언하는 위치에서 사용한다
    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">extension</span> <span class="kt">Int</span> <span class="p">{</span>
   <span class="c1">// 타입 저장 속성</span>
   <span class="kd">static</span> <span class="k">let</span> <span class="nv">zero</span><span class="p">:</span> <span class="k">Self</span> <span class="o">=</span> <span class="mi">0</span>   

   <span class="c1">// 인스턴스 계산속성</span>
   <span class="k">var</span> <span class="nv">zero</span><span class="p">:</span> <span class="k">Self</span> <span class="p">{</span>  
       <span class="k">return</span> <span class="mi">0</span>
   <span class="p">}</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">toZero</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
       <span class="k">return</span> <span class="k">Self</span><span class="o">.</span><span class="n">zero</span>     
   <span class="p">}</span>


   <span class="c1">// 인스턴스 메서드</span>
   <span class="kd">func</span> <span class="nf">toZero</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
       <span class="k">return</span> <span class="k">self</span><span class="o">.</span><span class="n">zero</span>    
   <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>프로토콜에서의 Self 사용
    <ul>
      <li>범용적으로 사용가능한 프로토콜에서 사용</li>
      <li>프로토콜을 채택하는 해당 타입을 가르킨다!</li>
    </ul>
  </li>
</ol>

<p><img src="https://user-images.githubusercontent.com/110437548/231165334-bcfdae77-cb1e-4e7a-a495-18ba9aadf314.png" alt="image" /></p>

<p>Some 프로토콜을 채택하는 Mouse에서는 name의 타입이 Mouse로 잘 들어가 있음을 알 수 있음!</p>

<p>이제 self 와 Self의 차이를 명확히 알고 사용할 수 있을 것 같다!</p>]]></content><author><name>Lee su-min</name></author><category term="Swift" /><category term="Swift" /><category term="self" /><category term="Self" /><category term="인스턴스" /><category term="타입" /><summary type="html"><![CDATA[self와 Self 비교]]></summary></entry><entry><title type="html">[알고리즘/Swift] 3687 성냥개비</title><link href="https://hanabzu.github.io/jekyll-theme-yat/2023/04/06/Baekjoon-3687" rel="alternate" type="text/html" title="[알고리즘/Swift] 3687 성냥개비" /><published>2023-04-06T00:00:00+00:00</published><updated>2023-04-06T00:00:00+00:00</updated><id>https://hanabzu.github.io/jekyll-theme-yat/2023/04/06/Baekjoon-3687</id><content type="html" xml:base="https://hanabzu.github.io/jekyll-theme-yat/2023/04/06/Baekjoon-3687"><![CDATA[<h2 id="문제-정보">문제 정보</h2>
<ul>
  <li>문제 출처: <a href="http://boj.kr/">백준 온라인 저지</a></li>
  <li>문제 링크:
    <ul>
      <li><a href="https://www.acmicpc.net/problem/3687">3687 성냥개비</a></li>
    </ul>
  </li>
  <li>제출 언어: Swift</li>
  <li>알고리즘 분류:
    <ul>
      <li>다이나믹 알고리즘</li>
      <li>그리디 알고리즘</li>
    </ul>
  </li>
</ul>

<p><br /> <br />
<img src="https://user-images.githubusercontent.com/110437548/230148240-ade5b80c-9699-4917-8c57-ea53959dca94.png" alt="image" /></p>

<hr />

<h2 id="풀이">풀이</h2>
<p>해당 문제는 min_dp 100개의 배열을 사용해서 해당 인덱스만큼의 성냥개비 개수로 만들 수 있는 최솟값을 배열에 넣었다.  <br />
이후, 성냥개비 개수가 주어지면 최솟값과 최댓값을 찾아야 하는데, 최댓값은 다음과 같은 알고리즘으로 쉽게 풀 수 있었다.</p>

<h2 id="-최댓값-구하기-">[ 최댓값 구하기 ]</h2>
<p>성냥개비 단 두개로 숫자 1을 만들어서 자릿수를 높여야 한다. <br />
그러므로 만약 성냥개비 개수가 짝수일 경우, 성냥개비 숫자 / 2 한 만큼 1을 붙여주면 된다. <br />
ex) 성냥개비 개수 = 8개일 경우 -&gt; 최댓값 1111     <br />
성냥개비 개수가 홀수일 경우, 1로 모든 성냥개비를 사용해서 채울 수 없으므로 가장 적은 개수로 만들 수 있는 가장 큰 수인 7을 앞에 붙여주고 남은 성냥개비로 1을 붙여준다 <br />
ex) 성냥개비 개수 = 7개일 경우 -&gt; 최댓값 711</p>

<h2 id="-최솟값-구하기-">[ 최솟값 구하기 ]</h2>

<p><img src="https://user-images.githubusercontent.com/110437548/230150015-c101017a-158e-46c6-a7a6-7be814bcf252.jpeg" alt="IMG_1990DD8FCF22-1" />  <br />
최솟값 구하기는 아까 말했듯이 dp를 이용하여 풀었다. <br />
위와 같이 규칙을 찾기 위해 계속 표를 작성해보았는데, 2 ~ 8까지는 직접 개수를 세서 적어놨고, 9부터는 점화식을 이용하여 dp 이전 원소들과 2 ~ 8 개수를 사용하여 
최솟값을 구할 수 있었다.  <br />
예를 들어, 성냥개비 10개로 만들 수 있는 최솟값을 구하려면 다음과 같은 알고리즘을 거쳐야한다.</p>
<ul>
  <li>8개로 만들 수 있는 최솟값 10, min_dp[2] 배열 값 1을 나열 -&gt; 101 <br />
<em>-&gt; 가장 처음에 보는 경우가 대부분 최댓값이므로, min값 갱신 초기화값으로 넣어준다</em></li>
  <li>7개로 만들 수 있는 최솟값 8, min_dp[3] 배열 값 7을 나열 -&gt; 87</li>
  <li>6로 만들 수 있는 최솟값 6, min_dp[4] 배열 값 4을 나열 -&gt; 64</li>
  <li>5개로 만들 수 있는 최솟값 2, min_dp[5] 배열 값 2을 나열 -&gt; 22</li>
  <li>4개로 만들 수 있는 최솟값 4, min_dp[6] 배열 값 6을 나열 -&gt; 46</li>
  <li>3개로 만들 수 있는 최솟값 7, min_dp[7] 배열 값 8을 나열 -&gt; 78</li>
</ul>

<p>이것을 코드화하면 다음과 같다</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// 9부터 점화식 적용</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">9</span><span class="o">...</span><span class="mi">100</span> <span class="p">{</span>
        <span class="c1">// 2번째 전 원소로 만든 숫자 뒤에 숫자 1을 붙인다 ex: i == 9 일 때, dp[7]*10 + dp[2] = 81</span>
        <span class="c1">// 초기값으로 가장 클 것 같은 수를 넣어주고, 계속 비교해본다</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="n">minNum</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">3</span><span class="o">...</span><span class="mi">7</span> <span class="p">{</span>
            <span class="c1">// 더해서 i를 만들 수 있는 조합으로 비교하여 최솟값을 찾는다</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="n">minNum</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="p">}</span>
    <span class="p">}</span> 
</code></pre></div></div>

<h2 id="코드">코드</h2>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Foundation</span>

<span class="c1">// 최솟값: 3을 입력받으면 dp 배열 앞부터 돌면서 3인 값 출력</span>

<span class="c1">// 2 ~ 8 까지의 수는 미리 minNum 배열에 넣어놓는다. -&gt; 점화식에서 일의 자리 수로 사용</span>
<span class="k">var</span> <span class="nv">minNum</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>

<span class="c1">// 해당 idx만큼의 성냥개비가 있을 때 만들 수 있는 최솟값을 넣어준다</span>
<span class="k">var</span> <span class="nv">dp</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="kt">Array</span><span class="p">(</span><span class="nv">repeating</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="mi">101</span><span class="p">)</span>
<span class="kd">func</span> <span class="nf">findMin</span><span class="p">()</span> <span class="p">{</span>
    
    <span class="c1">// 2 ~ 8 까지는 minNum 값이 최솟값임</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">2</span><span class="o">...</span><span class="mi">8</span> <span class="p">{</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">minNum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="p">}</span>
    
    <span class="c1">// 숫자는 0으로 시작할 수 없다는 조건이 없으므로 6개일 때 만들 수 있는 최솟값은 0이 아니라 그 다음 작은 수 6이 되어야 한다</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span>
    
    <span class="c1">// 9부터 점화식 적용</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">9</span><span class="o">...</span><span class="mi">100</span> <span class="p">{</span>
        <span class="c1">// 2번째 전 원소로 만든 숫자 뒤에 숫자 1을 붙인다 ex: i == 9 일 때, dp[7]*10 + dp[2] = 81</span>
        <span class="c1">// 초기값으로 가장 클 것 같은 수를 넣어주고, 계속 비교해본다</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="n">minNum</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">3</span><span class="o">...</span><span class="mi">7</span> <span class="p">{</span>
            <span class="c1">// 더해서 i를 만들 수 있는 조합으로 비교하여 최솟값을 찾는다</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="n">minNum</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 최댓값: 홀수인 경우 -&gt; 3개로 7 구성하여 맨 앞자리 만들고 나머지 2개로 1 구성하여 채운다 ex: 7 -&gt; 711</span>
<span class="c1">//       짝수인 경우 -&gt; 2개로 나눈 값을 1로 붙인다</span>
<span class="kd">func</span> <span class="nf">findMax</span><span class="p">(</span><span class="n">_</span> <span class="nv">num</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">result</span> <span class="o">=</span> <span class="kt">Array</span><span class="p">(</span><span class="nv">repeating</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">num</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span>
    <span class="p">}</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="kt">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">)}</span><span class="o">.</span><span class="nf">joined</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">""</span><span class="p">))</span>
    
<span class="p">}</span>

<span class="nf">findMin</span><span class="p">()</span>
<span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">1</span><span class="o">...</span><span class="kt">Int</span><span class="p">(</span><span class="nf">readLine</span><span class="p">()</span><span class="o">!</span><span class="p">)</span><span class="o">!</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">N</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="nf">readLine</span><span class="p">()</span><span class="o">!</span><span class="p">)</span><span class="o">!</span>
    
    <span class="c1">// 예외 케이스 출력</span>
    <span class="k">if</span> <span class="kt">N</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">separator</span><span class="p">:</span> <span class="s">" "</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="kt">N</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="nv">separator</span><span class="p">:</span> <span class="s">" "</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="kt">N</span><span class="p">],</span> <span class="nv">terminator</span><span class="p">:</span> <span class="s">" "</span><span class="p">)</span>
        <span class="nf">findMax</span><span class="p">(</span><span class="kt">N</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Lee su-min</name></author><category term="Algorithm" /><category term="백준" /><category term="문제풀이" /><category term="알고리즘" /><category term="그래프 이론" /><category term="그래프 탐색" /><category term="너비 우선 탐색" /><category term="깊이 우선 탐색" /><summary type="html"><![CDATA[문제 정보 문제 출처: 백준 온라인 저지 문제 링크: 3687 성냥개비 제출 언어: Swift 알고리즘 분류: 다이나믹 알고리즘 그리디 알고리즘]]></summary></entry><entry><title type="html">[Swift] App SandBox의 구조와 역할</title><link href="https://hanabzu.github.io/jekyll-theme-yat/2023/04/03/Swift-App-Sandbox" rel="alternate" type="text/html" title="[Swift] App SandBox의 구조와 역할" /><published>2023-04-03T00:00:00+00:00</published><updated>2023-04-03T00:00:00+00:00</updated><id>https://hanabzu.github.io/jekyll-theme-yat/2023/04/03/Swift-App-Sandbox</id><content type="html" xml:base="https://hanabzu.github.io/jekyll-theme-yat/2023/04/03/Swift-App-Sandbox"><![CDATA[<h2 id="ios-앱-샌드박스app-sandbox">iOS 앱 샌드박스(App SandBox)</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">샌드박스</code> 란 어린아이를 보호하기 위해 모래통에서만 놀도록 하는데서 유래한 접근 보안 모델</li>
  <li>iOS 에서는 하나의 앱마다 sandbox를 두고 공유되지 않도록 하여 접근에 대해 보호함</li>
  <li>sandbox 내의 파일만 정보를 주고 받을 수 있도록 함</li>
  <li>전략
    <ul>
      <li>앱이 시스템과 상호 작용하는 방식을 설명할 수 있습니다. 시스템에서 작업을 완료하는 데 필요한 접근권한을 앱에 “부여”하는 것이죠.</li>
      <li>열기 및 저장, 드래그 앤 드롭 및 친숙한 사용자 상호 작용을 통해 앱에 투명하게 추가 접근 권한을 부여할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/110437548/229504418-d3456290-034f-40ac-9258-4e76b7c2afbf.png" alt="Untitled" /></p>

<ul>
  <li>샌드박스가 없을 경우 → 앱에서 사용자의 모든 데이터에 접근 가능 &amp; 모든 시스템 자원이 앱에 접근 가능</li>
  <li>
    <p>이러한 보안 문제로 인해 iOS 정책은 사용자 앱에 모든 리소스들이나 사용자 데이터에 접근 불가능하도록 함</p>

    <p>(샌드박스 내의 파일만 접근 가능) <br />
<img src="https://user-images.githubusercontent.com/110437548/229504448-62e99476-410d-421d-9206-d66ca266756c.png" alt="image" /> <br />
<img src="https://user-images.githubusercontent.com/110437548/229504483-f663c870-0b25-4516-b413-f76a6c721372.png" alt="image" /></p>
  </li>
</ul>

<p>위와 같은 구조로 하나의 앱에 샌드박스가 구성되어 있다.</p>

<p>샌드박스 내에는 파일, 환경설정, 네트워크 리소스, 하드웨어 등에 대한 앱의 접근을 제한하는 세분화된 제어 집합이다.</p>

<p>데이터를 분리하고 고립시키고 보안 침해의 가능성을 낮춘다.</p>

<p>샌드박스 내부에는 다양한 역할을 하는 Container들이 있다.</p>

<p>하나 하나 살펴보자.</p>

<h2 id="1-bundle">1. Bundle</h2>

<ul>
  <li>Bundle의 경로 : Bundle.main.bundlePath</li>
  <li>Bundle의 특징
    <ul>
      <li>Bundle Container은 파일 시스템 내의 하나의 디렉토리</li>
      <li>실행 가능(Executable 파일), info.plist 파일, Resources(이미지, 사운드, strings 등)을 함께 그룹화</li>
      <li>읽기 전용이므로 수정이 필요한 경우 데이터 컨테이너로 옮겨서 작업</li>
      <li>iTunes, iCloud에 백업이 되지 않음</li>
      <li>컴파일이 실행되는 동안 파일이 생성</li>
    </ul>
  </li>
  <li>커스텀 파일을 어디에 배치해야 할지 결정할 때 앱 번들 구조에 대한 이해가 필요하다!</li>
</ul>

<h3 id="bundle-container의-구조">Bundle Container의 구조</h3>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MyApp.app
   MyApp
   MyAppIcon.png
   MySearchIcon.png
   Info.plist
   Default.png
   MainWindow.nib
   Settings.bundle
   MySettingsIcon.png
   iTunesArtwork
   en.lproj
      MyImage.png
   fr.lproj
      MyImage.png
</code></pre></div></div>

<ol>
  <li>MyApp (필수)
    <ul>
      <li>앱의 코드를 포함하고 있는 실행가능한 파일</li>
      <li>.app 확장자를 뗀 것이 실제 앱 프로젝트의 이름과 같음</li>
    </ul>
  </li>
  <li>Application icons((MyAppIcon.png, MySearchIcon.png, and MySettingsIcon.png)
    <ul>
      <li>앱 아이콘은 앱을 표시하는데 사용</li>
      <li>예를 들어 홈 스크린, 검색 결과 그리고 설정에서 앱이 앱의 아이콘으로 표시</li>
      <li>대부분의 경우 앱 아이콘을 꼭 포함해야 한다.</li>
    </ul>
  </li>
  <li>Info.plist (필수)
    <ul>
      <li>bundle ID, 버젼 번호 등 앱에 대한 구성(configuration) 정보를 포함하고 있는 파일</li>
    </ul>
  </li>
  <li>Launch images(Default.png)
    <ul>
      <li>앱의 시작 인터페이스를 보여주는 이미지이고 시스템은 제공된 런치 이미지 중 하나를 앱이 윈도우와 유저 인터페이스를 로드할 동안 임시로 사용한다.</li>
      <li>만약 임시 런처 이미지가 없다면 검은 화면이 보여진다.</li>
    </ul>
  </li>
  <li>MainWindow.nib
    <ul>
      <li>앱의 main nib file은 앱 런치 시간에 앱을 로드하기 위한 기본 인터페이스 객체를 포함한다.</li>
      <li>보통 앱의 메인 윈도우 객체와 앱 델리게이트 객체를 갖고 있다.</li>
    </ul>
  </li>
  <li>Settings.bundle
    <ul>
      <li>앱의 application-specific preferences를 포함하는 특별한 타입의 플러그인이다.</li>
      <li>이 번들은 property list와 구성하기 윈한 다른 리소스 파일이 포함되어 있고 preference를 보여준다.</li>
    </ul>
  </li>
  <li>Custom resource files
    <ul>
      <li>non-localized 리소스들은 최상위 디렉토리에 위치하고 localized 리소스는 language-specific 하위 디렉토리에 위치한다.</li>
    </ul>
  </li>
</ol>

<h2 id="2-data">2. Data</h2>

<p><img src="https://user-images.githubusercontent.com/110437548/229504536-639d5b6a-328b-458b-ad77-390395d9ff7c.png" alt="image" /></p>

<ol>
  <li>Documents</li>
</ol>

<ul>
  <li>유저가 앱을 통해 생성한 파일, 다운로드한 파일같은 것들을 저장해주는 디렉터리 (음악, pdf 등)</li>
  <li>설정에 따라 유저가 직접 파일 추가 및 삭제 가능 ( info.plist에서 UIFileSharingEnabled = YES로 설정)</li>
  <li>하드디스크와 같은 저장소 역할</li>
  <li>유저에게 노출되는 파일만 저장해야한다. 내부의 파일들은 ITuns와 iCloud에 백업된다</li>
</ul>

<p>ex) 그림 파일이나 텍스트 파일 / 메모 / 동영상</p>

<hr />

<p>1-1. Documents / inbox</p>

<ul>
  <li>Documents의 내부 inbox</li>
  <li><strong>외부 앱에서 요청하여 가져온 데이터를 inbox에 저장</strong>한다</li>
  <li>iCloud/iTunes에 백업된다.</li>
  <li>타 앱을 통해 전송받은 파일이 저장되는 디렉토리 (메일 앱 첨부파일 등)
    <ul>
      <li>읽거나 삭제 가능</li>
      <li>새 파일 추가나 기존 파일 수정을 불가능</li>
    </ul>
  </li>
</ul>

<p>ex) 메일의 첨부파일 / 사진 편집을 위해 사진첩에서 가져온 사진</p>

<hr />

<p>2-0. Library</p>

<ul>
  <li>유저 데이터 파일 및 임시 파일을 제외한 모든 파일들을 관리</li>
  <li>어플을 구동하기 위해 필요한 데이터 (유저 정보, 앱 설정 데이터) → 앱 구동을 이해 반드시 필요하나, 유저에게 공개되고 싶지 않은 민감한 데이터 저장시 사용</li>
  <li>앱의 기능이나 관리에 필요한 파일 저장</li>
  <li>주로 서브디렉토리인 Application Support와 Caches를 이용하지만 커스텀 디렉토리 사용이 가능</li>
  <li>Preference, Cookies, Saved Application State, WebKit등 필요할 때 시스템에서 자동 생성</li>
  <li>하위에 Application Support / Cache / Preferences 가 존재</li>
  <li>iCloud/iTunes에 백업된다.</li>
</ul>

<hr />

<p>2-1. Library / Application Supprot</p>

<ul>
  <li>앱의 기능 또는 관리를 위해 지속적으로 관리해야되는 파일 저장</li>
  <li>Documents와 거의 동일한 속성을 가지지만, 유저에 대한 노출 여부에 따라 위치가 결정됩니다.</li>
  <li>주로 BundleID나 회사명 등의 서브디렉토리로 만들어 관리</li>
  <li>CoreData 기본 저장 경로</li>
  <li>Realm은 Documents경로를 사용하는데 Documents는 노출이 되기 때문에 중요한 정보들이 저장되어있으면 Application Support폴더로 변경해서 사용하는 것이 좋다.</li>
  <li>iCloud/iTunes에 백업된다.</li>
</ul>

<p>ex) 메모장 앱의 코어 데이터 저장소로 사용 / 앱 생성 데이터 / 채팅앱의 대화내역</p>

<p>카카오톡의 경우 서버에 메시지가 보존되는 기간이 3일이다. 메시지가 기기를 통해서 들어오면 기기의 로컬 데이터베이스에 저장된다. 지속적으로 관리되고 유저의 접근이 닿지 않는곳, 백업이 되는 곳은 applicaion support이다.</p>

<hr />

<p>2-2. Library / Caches</p>

<ul>
  <li>앱의 동작 속도/데이터 절약 등을 위해 사용되는 공간</li>
  <li>예를 들어 Background에서 Foreground로 넘어올 때 스냅샷 이미지로 사용됨.</li>
  <li>앱이 쉽게 재생성할 수 있는 파일, 쉽게 다운로드 받을 수 있는 파일들이 저장됨.</li>
  <li>앱이 실행중에 삭제되지 않는 것이 보장되며 백업되지 않는다.</li>
</ul>

<p>ex) Background에서 Foreground로 넘어올 때 스냅샷 이미지 <br />
ex) 웹 서버에서 받아온 임시 데이터</p>

<hr />

<p>2-3. Library / Preferences</p>

<ul>
  <li>앱의 중요 설정들이 담김.</li>
  <li><strong>NSUserDefaults</strong> 를 사용해 파일을 만들어 저장</li>
</ul>

<hr />

<p>3-0. tmp</p>
<ul>
  <li>임시 데이터 저장</li>
  <li>잠깐 쓰고 버릴 데이터 저장</li>
  <li>OS나 유저에 의해 종종 비워지는 공간</li>
  <li>현재 앱 실행중에는 사용하지만 유지할 필요 없는 임시 파일 저장</li>
  <li>사용 후 필요없어진 파일은 직접 삭제해주는 것을 권장</li>
  <li>iCloud/iTunes에 백업되지 않는다.</li>
</ul>

<p>ex) 내 메모를 외부로 내보내기 위한 백업파일</p>

<h2 id="참고">참고</h2>

<p><a href="https://jinnify.tistory.com/26">https://jinnify.tistory.com/26</a></p>

<p><a href="https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFBundles/BundleTypes/BundleTypes.html#//apple_ref/doc/uid/10000123i-CH101-SW1">https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFBundles/BundleTypes/BundleTypes.html#//apple_ref/doc/uid/10000123i-CH101-SW1</a></p>]]></content><author><name>Lee su-min</name></author><category term="Swift" /><category term="Swift" /><category term="App Bundle" /><category term="SandBox" /><category term="Bundle Container" /><category term="Data Container" /><category term="iCloud Container" /><summary type="html"><![CDATA[iOS 앱 샌드박스(App SandBox)]]></summary></entry><entry><title type="html">[알고리즘/Swift] 14226 이모티콘</title><link href="https://hanabzu.github.io/jekyll-theme-yat/2023/04/01/Baekjoon-14226" rel="alternate" type="text/html" title="[알고리즘/Swift] 14226 이모티콘" /><published>2023-04-01T00:00:00+00:00</published><updated>2023-04-01T00:00:00+00:00</updated><id>https://hanabzu.github.io/jekyll-theme-yat/2023/04/01/Baekjoon-14226</id><content type="html" xml:base="https://hanabzu.github.io/jekyll-theme-yat/2023/04/01/Baekjoon-14226"><![CDATA[<h2 id="문제-정보">문제 정보</h2>
<ul>
  <li>문제 출처: <a href="http://boj.kr/">백준 온라인 저지</a></li>
  <li>문제 링크:
    <ul>
      <li><a href="https://www.acmicpc.net/problem/14226">14226 이모티콘</a></li>
    </ul>
  </li>
  <li>제출 언어: Swift</li>
  <li>알고리즘 분류:
    <ul>
      <li>그래프 이론</li>
      <li>그래프 탐색</li>
      <li>너비 우선 탐색</li>
    </ul>
  </li>
</ul>

<p><br /> <br />
<img src="https://user-images.githubusercontent.com/110437548/229067748-60fa3da6-e4ab-45be-afa0-f7b793a0f681.png" alt="image" /></p>

<hr />

<h2 id="풀이">풀이</h2>
<p><code class="language-plaintext highlighter-rouge">(1(초기 화면 개수), 0(초기 클립보드 개수), 0(연산 횟수))</code> 튜플을 큐에 넣어준 후, 하나씩 pop 해주며 해당 조건에 맞으면, 복사, 붙여넣기, 하나 삭제하기 연산을 수행한다. pop 했을 경우 원하고자 하는 이모티콘의 개수 S개가 되면 반복문을 종료하고 출력한다</p>

<ul>
  <li>visited 배열에 display의 방문 여부를 따지면 클립보드내의 개수와 상관없이 한 번만 고려하게 되므로 visited[display][clip] 배열에 방문한 곳을 기록한다</li>
  <li>visited 배열은 S의 값이 최대 1000 이므로 1000 x 1000 배열로 생성해주었다</li>
  <li>가장 처음 상태에서 복사를 해야하므로 복사하기 조건을 고려할 때 복사 후의 화면의 이모티콘의 개수가 1~=1000 범위안에 들도록 하였다</li>
  <li>하나 삭제하기 연산은 삭제 후의 화면의 이모티콘의 개수가 2~=1000 범위안에 들도록 하였다 (S의 범위)</li>
  <li>붙여넣기 연산은 클립보드에 이모티콘이 있고, 붙여넣기한 후의 화면의 이모티콘의 개수가 1000개 이하가 되도록 하였다</li>
  <li>각각 연산시에 visited[display+clip][clip] = true 를 해주고 큐에 연산한 튜플을 넣어주었다</li>
  <li>방문을 true로 할 때, pop한 후에 하는 것보다 push할 때 시간복잡도가 더 빨랐다</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 시간 초과</span>
<span class="k">let</span> <span class="p">(</span><span class="nv">display</span><span class="p">,</span> <span class="nv">clip</span><span class="p">,</span> <span class="nv">time</span><span class="p">)</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="nf">popFirst</span><span class="p">()</span>
<span class="n">visited</span><span class="p">[</span><span class="n">display</span><span class="p">][</span><span class="n">clip</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span>
</code></pre></div></div>

<h2 id="코드">코드</h2>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Foundation</span>
<span class="kd">class</span> <span class="kt">Queue</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">inbox</span><span class="p">:</span> <span class="p">[</span><span class="kt">T</span><span class="p">]</span>
    <span class="k">var</span> <span class="nv">outbox</span><span class="p">:</span> <span class="p">[</span><span class="kt">T</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">var</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">inbox</span><span class="o">.</span><span class="n">count</span> <span class="o">+</span> <span class="n">outbox</span><span class="o">.</span><span class="n">count</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">isEmpty</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">inbox</span><span class="o">.</span><span class="n">isEmpty</span> <span class="o">&amp;&amp;</span> <span class="n">outbox</span><span class="o">.</span><span class="n">isEmpty</span>
    <span class="p">}</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">queue</span><span class="p">:</span> <span class="p">[</span><span class="kt">T</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">inbox</span> <span class="o">=</span> <span class="n">queue</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">pushLast</span><span class="p">(</span><span class="n">_</span> <span class="nv">element</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">inbox</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">pushFirst</span><span class="p">(</span><span class="n">_</span> <span class="nv">element</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">outbox</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">popLast</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">T</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">inbox</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span>
            <span class="n">inbox</span> <span class="o">=</span> <span class="n">outbox</span><span class="o">.</span><span class="nf">reversed</span><span class="p">()</span>
            <span class="n">outbox</span><span class="o">.</span><span class="nf">removeAll</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">inbox</span><span class="o">.</span><span class="nf">popLast</span><span class="p">()</span><span class="o">!</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">popFirst</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">T</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">outbox</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span>
            <span class="n">outbox</span> <span class="o">=</span> <span class="n">inbox</span><span class="o">.</span><span class="nf">reversed</span><span class="p">()</span>
            <span class="n">inbox</span><span class="o">.</span><span class="nf">removeAll</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">outbox</span><span class="o">.</span><span class="nf">popLast</span><span class="p">()</span><span class="o">!</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">S</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="nf">readLine</span><span class="p">()</span><span class="o">!</span><span class="p">)</span><span class="o">!</span>
<span class="k">var</span> <span class="nv">queue</span> <span class="o">=</span> <span class="kt">Queue</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="k">var</span> <span class="nv">visited</span> <span class="o">=</span> <span class="kt">Array</span><span class="p">(</span><span class="nv">repeating</span><span class="p">:</span> <span class="kt">Array</span><span class="p">(</span><span class="nv">repeating</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="mi">2000</span><span class="p">),</span> <span class="nv">count</span><span class="p">:</span> <span class="mi">2000</span><span class="p">)</span>

<span class="k">while</span> <span class="o">!</span><span class="n">queue</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="nv">display</span><span class="p">,</span> <span class="nv">clip</span><span class="p">,</span> <span class="nv">time</span><span class="p">)</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="nf">popFirst</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">display</span> <span class="o">==</span> <span class="kt">S</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="k">break</span>
    <span class="p">}</span>
    <span class="c1">// 복사하기</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">1</span><span class="o">...</span><span class="mi">1000</span><span class="p">)</span> <span class="o">~=</span> <span class="n">display</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">display</span><span class="p">][</span><span class="n">display</span><span class="p">]</span> <span class="p">{</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">display</span><span class="p">][</span><span class="n">display</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span>
            <span class="n">queue</span><span class="o">.</span><span class="nf">pushLast</span><span class="p">((</span><span class="n">display</span><span class="p">,</span> <span class="n">display</span><span class="p">,</span> <span class="n">time</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 삭제하기</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">2</span><span class="o">...</span><span class="mi">1000</span><span class="p">)</span> <span class="o">~=</span> <span class="n">display</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">display</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">clip</span><span class="p">]</span> <span class="p">{</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">display</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">clip</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span>
            <span class="n">queue</span><span class="o">.</span><span class="nf">pushLast</span><span class="p">((</span><span class="n">display</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">clip</span><span class="p">,</span> <span class="n">time</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 붙여넣기</span>
    <span class="c1">// 클립보드가 비어있지 않고, 붙여넣는 값과 화면의 값의 합이 1000을 넘지 않는 경우</span>
    <span class="k">if</span> <span class="n">clip</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">display</span><span class="o">+</span><span class="n">clip</span> <span class="o">&lt;=</span> <span class="mi">1000</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">display</span><span class="o">+</span><span class="n">clip</span><span class="p">][</span><span class="n">clip</span><span class="p">]</span> <span class="p">{</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">display</span><span class="o">+</span><span class="n">clip</span><span class="p">][</span><span class="n">clip</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span>
            <span class="n">queue</span><span class="o">.</span><span class="nf">pushLast</span><span class="p">((</span><span class="n">display</span><span class="o">+</span><span class="n">clip</span><span class="p">,</span> <span class="n">clip</span><span class="p">,</span> <span class="n">time</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>]]></content><author><name>Lee su-min</name></author><category term="Algorithm" /><category term="백준" /><category term="문제풀이" /><category term="알고리즘" /><category term="그래프 이론" /><category term="그래프 탐색" /><category term="너비 우선 탐색" /><category term="깊이 우선 탐색" /><summary type="html"><![CDATA[문제 정보 문제 출처: 백준 온라인 저지 문제 링크: 14226 이모티콘 제출 언어: Swift 알고리즘 분류: 그래프 이론 그래프 탐색 너비 우선 탐색]]></summary></entry><entry><title type="html">[Swift] 타입 캐스팅</title><link href="https://hanabzu.github.io/jekyll-theme-yat/2023/03/31/Swift-Type-Casting" rel="alternate" type="text/html" title="[Swift] 타입 캐스팅" /><published>2023-03-31T00:00:00+00:00</published><updated>2023-03-31T00:00:00+00:00</updated><id>https://hanabzu.github.io/jekyll-theme-yat/2023/03/31/Swift-Type-Casting</id><content type="html" xml:base="https://hanabzu.github.io/jekyll-theme-yat/2023/03/31/Swift-Type-Casting"><![CDATA[<h2 id="타입-캐스팅">타입 캐스팅</h2>

<h3 id="is-연산자type-check-operator">is 연산자(type check operator)</h3>

<ul>
  <li>인스턴스의 타입을 검사함</li>
  <li><code class="language-plaintext highlighter-rouge">인스턴스 is 타입</code> 형태로 사용 (이항 연산자)</li>
  <li>상속은 <code class="language-plaintext highlighter-rouge">저장속성 확장 개념</code>이기 때문에 하위 클래스가 상위 클래스의 타입일 수는 있지만, 상위 클래스가 하위 클래스 타입일 수는 없다.</li>
</ul>

<p>(메모리 관점에서 하위 클래스의 인스턴스는 상위 클래스의 속성을 가지고 있지만, 상위 클래스는 하위 클래스의 속성을 가지고 있지 않다.)</p>

<p>Person 인스턴스 is Undergraduate(false)</p>

<p>Undergraduate인스턴스 is Person (true)</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Person</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">id</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">var</span> <span class="nv">name</span> <span class="o">=</span> <span class="s">"데이지"</span>
    <span class="k">var</span> <span class="nv">email</span> <span class="o">=</span> <span class="s">"abc@naver.com"</span>
<span class="p">}</span>

<span class="c1">// Person 클래스 상속</span>
<span class="kd">class</span> <span class="kt">Student</span><span class="p">:</span> <span class="kt">Person</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">studentId</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="c1">// Student 클래스 상속</span>
<span class="kd">class</span> <span class="kt">Undergraduate</span><span class="p">:</span> <span class="kt">Student</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">major</span> <span class="o">=</span> <span class="s">"정보통신공학과"</span>
<span class="p">}</span>

<span class="c1">// is 연산자를 활용한 타입 검사</span>

<span class="k">var</span> <span class="nv">person</span> <span class="o">=</span> <span class="kt">Person</span><span class="p">()</span>
<span class="k">var</span> <span class="nv">student</span> <span class="o">=</span> <span class="kt">Student</span><span class="p">()</span>
<span class="k">var</span> <span class="nv">undergraduate</span> <span class="o">=</span> <span class="kt">Undergraduate</span><span class="p">()</span>

<span class="n">person</span> <span class="k">is</span> <span class="kt">Person</span> <span class="c1">// true</span>
<span class="n">person</span> <span class="k">is</span> <span class="kt">Student</span>  <span class="c1">// false</span>
<span class="n">person</span> <span class="k">is</span> <span class="kt">Undergraduate</span> <span class="c1">// false</span>

<span class="n">student</span> <span class="k">is</span> <span class="kt">Person</span> <span class="c1">// true</span>
<span class="n">student</span> <span class="k">is</span> <span class="kt">Student</span> <span class="c1">// true</span>
<span class="n">student</span> <span class="k">is</span> <span class="kt">Undergraduate</span> <span class="c1">// false</span>

<span class="n">undergraduate</span> <span class="k">is</span> <span class="kt">Person</span> <span class="c1">// true</span>
<span class="n">undergraduate</span> <span class="k">is</span> <span class="kt">Student</span> <span class="c1">// true</span>
<span class="n">undergraduate</span> <span class="k">is</span> <span class="kt">Undergraduate</span> <span class="c1">// true</span>

<span class="k">let</span> <span class="nv">person1</span> <span class="o">=</span> <span class="kt">Person</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">student1</span> <span class="o">=</span> <span class="kt">Student</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">undergraduate1</span> <span class="o">=</span> <span class="kt">Undergraduate</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">people</span> <span class="o">=</span> <span class="p">[</span><span class="n">person</span><span class="p">,</span> <span class="n">person1</span><span class="p">,</span> <span class="n">student</span><span class="p">,</span> <span class="n">student1</span><span class="p">,</span> <span class="n">undergraduate</span><span class="p">,</span> <span class="n">undergraduate1</span><span class="p">]</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">one</span> <span class="k">in</span> <span class="n">people</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">one</span> <span class="k">is</span> <span class="kt">Student</span> <span class="p">{</span>
        <span class="n">studentNumber</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// student, student1, undergraduate, undergraduate1 인스턴스가 Student 타입임</span>
<span class="nf">print</span><span class="p">(</span><span class="n">studentNumber</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="as-연산자type-cast-operator">as 연산자(type cast operator)</h3>

<ul>
  <li>클래스 계층 상의 타입 변환</li>
  <li><code class="language-plaintext highlighter-rouge">Upcasting</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">인스턴스 as 타입</code>  형태</li>
      <li>하위 클래스 인스턴스를 상위 클래스 타입으로 인식</li>
      <li>항상 성공한다</li>
    </ul>
  </li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">student</span><span class="p">:</span> <span class="kt">Student</span> <span class="o">=</span> <span class="kt">Student</span><span class="p">()</span>
<span class="n">student</span><span class="o">.</span><span class="n">studentId</span>
<span class="c1">// 업캐스팅, 컴파일러가 에러가 발생할 가능성이 없다는 것을 안다</span>
<span class="k">let</span> <span class="nv">person</span> <span class="o">=</span> <span class="n">student</span> <span class="k">as</span> <span class="kt">Person</span>
<span class="n">person</span><span class="o">.</span><span class="n">name</span>
<span class="n">person</span><span class="o">.</span><span class="n">email</span>
<span class="n">person</span><span class="o">.</span><span class="n">studentId</span> <span class="c1">// 컴파일 에러 Value of type 'Person' has no member 'studentId'</span>

<span class="c1">// 위 코드와 같은 업캐스팅 예제</span>
<span class="k">let</span> <span class="nv">student1</span><span class="p">:</span> <span class="kt">Person</span> <span class="o">=</span> <span class="kt">Student</span><span class="p">()</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Downcasting</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">인스턴스 as?/! 타입</code> 형태</li>
      <li>상위 클래스 인스턴스를 하위 클래스 타입으로 인식</li>
      <li>as? 연산자일 경우, 참이면 반환값은 Optional / 실패 시 nil 반환</li>
      <li>as! 연산자일 경우, 참이면 반환값은 Optional 타입의 값을 강제 언래핑한 타입 / 실패 시 런타임 오류 !!</li>
    </ul>
  </li>
  <li>
    <p>타입 캐스팅은 인스턴스 사용 시 어떤 타입으로 사용할 지 메모리 구조에 대한 힌트를 변경하는 것!</p>

    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// 힙 메모리에 이미 Undergraduate() 데이터를 생성하여 5개의 저장 속성을 가지지만</span>
  <span class="c1">// 변수에 정의된 타입은 Person 이므로, 컴파일러는 Person 타입이 들어있다고 인식</span>
  <span class="c1">// 업캐스팅</span>
  <span class="k">let</span> <span class="nv">person</span><span class="p">:</span> <span class="kt">Person</span> <span class="o">=</span> <span class="kt">Undergraduate</span><span class="p">()</span>
  <span class="c1">// let person: Undergraduate = Person() (x) 참고로 하위 클래스의 변수에 상위 클래스를 담을 수는 없음</span>
    
  <span class="n">person</span><span class="o">.</span><span class="n">id</span>
  <span class="n">person</span><span class="o">.</span><span class="n">email</span>
  <span class="c1">// 컴파일 에러 Value of type 'Person' has no member 'major'</span>
  <span class="n">person</span><span class="o">.</span><span class="n">major</span>
    
  <span class="n">person</span> <span class="k">is</span> <span class="kt">Undergraduate</span> <span class="c1">// true</span>
  <span class="n">person</span> <span class="k">is</span> <span class="kt">Person</span> <span class="c1">// true</span>
    
  <span class="k">let</span> <span class="nv">ppp</span> <span class="o">=</span> <span class="n">person</span> <span class="k">as?</span> <span class="kt">Undergraduate</span>  <span class="c1">// ppp -&gt; Undergraduate? 타입</span>
    
  <span class="k">if</span> <span class="k">let</span> <span class="nv">newPerson</span> <span class="o">=</span> <span class="n">person</span> <span class="k">as?</span> <span class="kt">Undergraduate</span> <span class="p">{</span>  <span class="c1">// if let 바인딩과 함께 사용</span>
    		
      <span class="n">newPerson</span><span class="o">.</span><span class="n">major</span>
      <span class="nf">print</span><span class="p">(</span><span class="n">newPerson</span><span class="o">.</span><span class="n">major</span><span class="p">)</span>
  <span class="p">}</span>
    
  <span class="c1">// 실제로 인스턴스의 접근 범위를 늘려주는 것 뿐임</span>
    
  <span class="k">let</span> <span class="nv">person3</span><span class="p">:</span> <span class="kt">Undergraduate</span> <span class="o">=</span> <span class="n">person</span> <span class="k">as!</span> <span class="kt">Undergraduate</span>
  <span class="n">person3</span><span class="o">.</span><span class="n">major</span>
    
  <span class="k">let</span> <span class="nv">people</span> <span class="o">=</span> <span class="p">[</span><span class="n">person1</span><span class="p">,</span> <span class="n">person2</span><span class="p">,</span> <span class="n">student1</span><span class="p">,</span> <span class="n">student2</span><span class="p">,</span> <span class="n">undergraduate1</span><span class="p">,</span> <span class="n">undergraduate2</span><span class="p">]</span>
  <span class="k">var</span> <span class="nv">studentArray</span><span class="p">:</span> <span class="p">[</span><span class="kt">Student</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">someone</span> <span class="k">in</span> <span class="n">people</span> <span class="p">{</span>
      <span class="k">if</span> <span class="n">someone</span> <span class="k">is</span> <span class="kt">Student</span> <span class="p">{</span>
          <span class="n">studentArray</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">someone</span><span class="p">)</span>
      <span class="p">}</span>
  <span class="p">}</span>
    
  <span class="k">var</span> <span class="nv">studentArray</span><span class="p">:</span> <span class="p">[</span><span class="kt">Student</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">someOne</span> <span class="k">in</span> <span class="n">people</span> <span class="p">{</span>
      <span class="k">if</span> <span class="n">someOne</span> <span class="k">is</span> <span class="kt">Student</span> <span class="p">{</span>
          <span class="k">if</span> <span class="k">let</span> <span class="nv">one</span> <span class="o">=</span> <span class="n">someOne</span> <span class="k">as?</span> <span class="kt">Student</span> <span class="p">{</span>
              <span class="n">studentArray</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">one</span><span class="p">)</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// 컴파일러는 people 배열을 인스턴스의 공통 분모인 [Person] 타입으로 인식</span>
  <span class="c1">// is 연산자는 실제 메모리 내 데이터가 어떠한 타입이고, 어떠한 타입을 상속받았나 확인 시 사용</span>
  <span class="c1">// 배열 내 아이템들은 각자의 타입 데이터를 가지고 있지만, 컴파일러는 Person 타입으로 인식한다</span>
</code></pre></div>    </div>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">let person: Person = Undergraduate()</code> 의 person은 Person 타입으로 업캐스팅 되었지만 실제 데이터는 Undergraduate 타입이라 Undergraduate() 클래스를 가리키고 있기 때문에 study()나 party() 함수는 실행이 불가능하지만, walk() 함수를 실행할 경우, Undergraduate 클래스에서 재정의한 walk()-2 함수를 시행한다</li>
      <li>
        <p>(메서드 디스패치)</p>
      </li>
      <li>as 연산자의 활용</li>
      <li>Bridging → 서로 호환되는 형식을 캐스팅해서 쉽게 사용하는 것</li>
      <li>swift에서는 여전히 objective-C의 프레임워크를 많이 사용</li>
      <li>서로 완전히 상호 호환 가능 (업 다운 캐스팅 개념 x)</li>
      <li>
        <p>강제 캐스팅할 필요가 없으므로 <code class="language-plaintext highlighter-rouge">as</code> 연산자를 활용한다</p>

        <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">let</span> <span class="nv">str</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"HELLO"</span>
 <span class="k">let</span> <span class="nv">nsStr</span> <span class="o">=</span> <span class="n">str</span> <span class="k">as</span> <span class="kt">NSString</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h3 id="상속과-다형성">상속과 다형성</h3>

<ul>
  <li>다형성이란</li>
  <li>하나의 객체가 여러가지의 타입으로 표현될 수 있음</li>
  <li>하나의 타입으로 여러 종류의 객체를 해석할 수 있음</li>
  <li>클래스의 상속 + 프로토콜과 깊은 연관성</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Person</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">id</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">var</span> <span class="nv">name</span> <span class="o">=</span> <span class="s">"이름"</span>
    <span class="k">var</span> <span class="nv">email</span> <span class="o">=</span> <span class="s">"abc@gmail.com"</span>
    
    <span class="kd">func</span> <span class="nf">walk</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"사람이 걷는다."</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">Student</span><span class="p">:</span> <span class="kt">Person</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">studentId</span> <span class="o">=</span> <span class="mi">1</span>
   
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">walk</span><span class="p">()</span> <span class="p">{</span>         <span class="c1">// 재정의 메서드. walk() - 1</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"학생이 걷는다."</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">study</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"학생이 공부한다."</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">Undergraduate</span><span class="p">:</span> <span class="kt">Student</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">major</span> <span class="o">=</span> <span class="s">"전공"</span>
    
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">walk</span><span class="p">()</span> <span class="p">{</span>       <span class="c1">// 재정의 메서드. walk() - 2</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"대학생이 걷는다."</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">study</span><span class="p">()</span> <span class="p">{</span>      <span class="c1">// 재정의 메서드. study() - 1</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"대학생이 공부한다."</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">party</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"대학생이 파티를 한다."</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">person1</span> <span class="o">=</span> <span class="kt">Person</span><span class="p">()</span>
<span class="n">person1</span><span class="o">.</span><span class="nf">walk</span><span class="p">()</span> <span class="c1">//사람이 걷는다. 출력</span>

<span class="k">let</span> <span class="nv">student</span> <span class="o">=</span> <span class="kt">Student</span><span class="p">()</span>
<span class="n">student</span><span class="o">.</span><span class="nf">walk</span><span class="p">()</span> <span class="c1">// 학생이 걷는다. 출력</span>
<span class="n">student</span><span class="o">.</span><span class="nf">study</span><span class="p">()</span> <span class="c1">// 학생이 공부한다. 출력</span>

<span class="k">let</span> <span class="nv">student1</span><span class="p">:</span> <span class="kt">Person</span> <span class="o">=</span> <span class="kt">Student</span><span class="p">()</span>
<span class="n">student1</span><span class="o">.</span><span class="nf">walk</span><span class="p">()</span> <span class="c1">// 학생이 걷는다. 출력  -&gt; 다형성의 예 </span>
<span class="n">student1</span><span class="o">.</span><span class="nf">study</span><span class="p">()</span> <span class="c1">// 컴파일 에러 Value of type 'Person' has no member 'study'</span>

<span class="k">let</span> <span class="nv">people</span><span class="p">:</span> <span class="p">[</span><span class="kt">Person</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Person</span><span class="p">(),</span> <span class="kt">Student</span><span class="p">(),</span> <span class="kt">Undergraduate</span><span class="p">()]</span>

<span class="c1">// 반복문</span>
<span class="k">for</span> <span class="n">person</span> <span class="k">in</span> <span class="n">people</span> <span class="p">{</span>
    <span class="n">person</span><span class="o">.</span><span class="nf">walk</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// 사람이 걷는다. 출력</span>
<span class="c1">// 학생이 걷는다. 출력</span>
<span class="c1">// 대학생이 걷는다. 출력</span>
</code></pre></div></div>

<ul>
  <li>
    <p>상속 관계에서 다형성은 메서드를 통해 발현된다.</p>
  </li>
  <li>업캐스팅된 타입 (Person) 형태이더라도 메서드 호출 시 실제 메모리에서 구현된 “재정의”된 메서드 (Walk() -1 )가 호출되어 실행된다.</li>
  <li>타입의 저장 형태는 속성/메서드에 대한 접근 가능 범위를 나타내는 것이고, (Person)</li>
  <li>다형성은 인스턴스에서 메모리의 실제 구현 내용에 대한 것임 (Student)</li>
  <li>메서드는 재정의 가능하고, 메서드 테이블을 통해 동작한다 !</li>
</ul>

<h3 id="가상-메소드-테이블이란"><strong>가상 메소드 테이블이란?</strong></h3>

<p>가상 메소드 테이블은 동적 디스패치를 지원하기 위해 프로그래밍 언어에서 사용되는 메커니즘이다. 클래스가 가상 함수을 정의할 때마다, 대부분의 컴파일러들은 클래스에 숨겨진 멤버 변수를 추가하는데, 이것은 함수들에 대한 포인터들의 배열들을 가리킨다</p>

<h3 id="any-anyobject-타입">Any/ AnyObject 타입</h3>

<ol>
  <li>Any
    <ul>
      <li>기본 타입(Int, String, Bool 등..) 과 커스텀 타입(클래스, 구조체, 열거형, 함수, 클로저) 까지 포함하여 어떠한 타입의 인스턴스도 표현할 있는 타입</li>
      <li>옵셔널 타입도 포함</li>
      <li>단점 : 저장된 타입의 메모리 구조를 알 수 없기 때문에 항상 타입 캐스팅해서 사용해야 된다.</li>
      <li>장점 : 모든 타입을 다 담을 수 있는 배열 생성 가능!</li>
    </ul>

    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">var</span> <span class="nv">some</span><span class="p">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="s">"Swift"</span>
 <span class="c1">// some.count -&gt; 컴파일 에러 Value of type 'Any' has no member 'count'</span>
    
 <span class="c1">// String 타입으로 타입 캐스팅 후 문자열 메서드 사용 가능</span>
 <span class="k">if</span> <span class="k">let</span> <span class="nv">str</span> <span class="o">=</span> <span class="kd">some</span> <span class="k">as?</span> <span class="kt">String</span> <span class="p">{</span>
     <span class="nf">print</span><span class="p">(</span><span class="n">str</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
 <span class="p">}</span>
    
 <span class="nf">print</span><span class="p">(</span><span class="nf">type</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="kd">some</span><span class="p">))</span> <span class="c1">// String 출력</span>
 <span class="kd">some</span> <span class="o">=</span> <span class="mi">10</span>
 <span class="kd">some</span> <span class="o">=</span> <span class="mf">3.2</span>
 <span class="nf">print</span><span class="p">(</span><span class="nf">type</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="kd">some</span><span class="p">))</span> <span class="c1">// Double 출력</span>
    
 <span class="k">let</span> <span class="nv">array</span><span class="p">:</span> <span class="p">[</span><span class="kt">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="s">"안녕"</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="kt">Person</span><span class="p">(),</span> <span class="kt">Superman</span><span class="p">(),</span> <span class="p">{(</span><span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">in</span> <span class="k">return</span> <span class="n">name</span><span class="p">}]</span>
    
 <span class="c1">//array[1].count</span>
 <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">as!</span> <span class="kt">String</span><span class="p">)</span><span class="o">.</span><span class="n">count</span>
    
 <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="k">in</span> <span class="n">array</span><span class="o">.</span><span class="nf">enumerated</span><span class="p">()</span> <span class="p">{</span>
 		<span class="c1">// is/ as 패턴으로 switch문에서 case 별로 분기처리 가능!</span>
     <span class="k">switch</span> <span class="n">item</span> <span class="p">{</span>
     <span class="k">case</span> <span class="k">is</span> <span class="kt">Int</span><span class="p">:</span>                                  <span class="c1">// item is Int</span>
         <span class="nf">print</span><span class="p">(</span><span class="s">"Index - </span><span class="se">\(</span><span class="n">index</span><span class="se">)</span><span class="s">: 정수입니다."</span><span class="p">)</span>
     <span class="k">case</span> <span class="k">let</span> <span class="nv">num</span> <span class="k">as</span> <span class="kt">Double</span><span class="p">:</span> <span class="c1">// 이미 Double 타입으로 변환 가능한 경우를 다루므로 as  // let num = item as Double</span>
         <span class="nf">print</span><span class="p">(</span><span class="s">"Index - </span><span class="se">\(</span><span class="n">index</span><span class="se">)</span><span class="s">: 소수 </span><span class="se">\(</span><span class="n">num</span><span class="se">)</span><span class="s">입니다."</span><span class="p">)</span>
     <span class="k">case</span> <span class="k">is</span> <span class="kt">String</span><span class="p">:</span>                               <span class="c1">// item is String</span>
         <span class="nf">print</span><span class="p">(</span><span class="s">"Index - </span><span class="se">\(</span><span class="n">index</span><span class="se">)</span><span class="s">: 문자열입니다."</span><span class="p">)</span>
     <span class="k">case</span> <span class="k">let</span> <span class="nv">person</span> <span class="k">as</span> <span class="kt">Person</span><span class="p">:</span>                    <span class="c1">// let person = item as Person</span>
         <span class="nf">print</span><span class="p">(</span><span class="s">"Index - </span><span class="se">\(</span><span class="n">index</span><span class="se">)</span><span class="s">: 사람입니다."</span><span class="p">)</span>
         <span class="nf">print</span><span class="p">(</span><span class="s">"이름은 </span><span class="se">\(</span><span class="n">person</span><span class="o">.</span><span class="n">name</span><span class="se">)</span><span class="s">입니다."</span><span class="p">)</span>
         <span class="nf">print</span><span class="p">(</span><span class="s">"나이는 </span><span class="se">\(</span><span class="n">person</span><span class="o">.</span><span class="n">age</span><span class="se">)</span><span class="s">입니다."</span><span class="p">)</span>
     <span class="k">case</span> <span class="nf">is</span> <span class="p">(</span><span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">:</span>                   <span class="c1">// item is (String) -&gt; String</span>
         <span class="nf">print</span><span class="p">(</span><span class="s">"Index - </span><span class="se">\(</span><span class="n">index</span><span class="se">)</span><span class="s">: 클로저 타입입니다."</span><span class="p">)</span>
     <span class="k">default</span><span class="p">:</span>
         <span class="nf">print</span><span class="p">(</span><span class="s">"Index - </span><span class="se">\(</span><span class="n">index</span><span class="se">)</span><span class="s">: 그 이외의 타입입니다."</span><span class="p">)</span>
     <span class="p">}</span>
 <span class="p">}</span>
 <span class="c1">// 출력 결과</span>
    
 <span class="c1">// Index - 1: 문자열입니다.</span>
 <span class="c1">// Index - 2: 소수 3.5입니다.</span>
 <span class="c1">// Index - 3: 사람입니다.</span>
 <span class="c1">// 이름은 이름입니다.</span>
 <span class="c1">// 나이는 10입니다.</span>
 <span class="c1">// Index - 4: 그 이외의 타입입니다.</span>
 <span class="c1">// Index - 5: 클로저 타입입니다.</span>
</code></pre></div>    </div>

    <ul>
      <li>옵셔널 값의 Any 반환</li>
      <li>Any는 모든 타입, 옵셔널 타입까지 포함하므로 옵셔널 값을 사용할 때 Any 타입으로 변환해주면 컴파일러의 경고를 없앨 수 있다.</li>
      <li>
        <p>옵셔널값은 임시적인 값이므로 옵셔널을 벗겨줘야 하는데 Any로 변환하는 것은 그 자체를 사용하겠다는 의미이다.</p>

        <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">let</span> <span class="nv">optionalNumber</span><span class="p">:</span> <span class="kt">Int</span><span class="p">?</span> <span class="o">=</span> <span class="mi">3</span>
 <span class="nf">print</span><span class="p">(</span><span class="n">optionalNumber</span><span class="p">)</span>          <span class="c1">// 경고</span>
 <span class="nf">print</span><span class="p">(</span><span class="n">optionalNumber</span> <span class="k">as</span> <span class="kt">Any</span><span class="p">)</span>   <span class="c1">// 경고 없음</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>AnyObject
    <ul>
      <li>어떤 클래스 타입의 인스턴스도 표현할 수 있는 타입</li>
      <li>구조체 인스턴스 불가능 클래스만 !</li>
    </ul>

    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">let</span> <span class="nv">objArray</span><span class="p">:</span> <span class="p">[</span><span class="kt">AnyObject</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Person</span><span class="p">(),</span> <span class="kt">Superman</span><span class="p">(),</span> <span class="kt">NSString</span><span class="p">()]</span>
    
 <span class="c1">//objArray[0].name</span>
 <span class="p">(</span><span class="n">objArray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">as!</span> <span class="kt">Person</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>
</code></pre></div>    </div>
  </li>
</ol>]]></content><author><name>Lee su-min</name></author><category term="Swift" /><category term="Swift" /><category term="Type Casting" /><category term="is/as" /><category term="Down Casting" /><category term="Up Casting" /><category term="다형성" /><category term="Any" /><category term="AnyObject" /><summary type="html"><![CDATA[타입 캐스팅]]></summary></entry><entry><title type="html">[알고리즘/Swift] 13549,13913 숨바꼭질 3,4</title><link href="https://hanabzu.github.io/jekyll-theme-yat/2023/03/29/Baekjoon-13549-13913" rel="alternate" type="text/html" title="[알고리즘/Swift] 13549,13913 숨바꼭질 3,4" /><published>2023-03-29T00:00:00+00:00</published><updated>2023-03-29T00:00:00+00:00</updated><id>https://hanabzu.github.io/jekyll-theme-yat/2023/03/29/Baekjoon-13549-13913</id><content type="html" xml:base="https://hanabzu.github.io/jekyll-theme-yat/2023/03/29/Baekjoon-13549-13913"><![CDATA[<h2 id="문제-정보">문제 정보</h2>
<ul>
  <li>문제 출처: <a href="http://boj.kr/">백준 온라인 저지</a></li>
  <li>문제 링크:
    <ul>
      <li><a href="https://www.acmicpc.net/problem/13549">13549 숨바꼭질 3</a></li>
      <li><a href="https://www.acmicpc.net/problem/13913">13913 숨바꼭질 4</a></li>
    </ul>
  </li>
  <li>제출 언어: Swift</li>
  <li>알고리즘 분류:
    <ul>
      <li>그래프 이론</li>
      <li>그래프 탐색</li>
      <li>너비 우선 탐색</li>
      <li>다익스트라</li>
    </ul>
  </li>
</ul>

<p><br /> <br />
 두 문제가 <a href="https://sumin305.github.io/2023/03/27/Baekjoon-12851">숨바꼭질 2</a> 문제와 풀이가 유사해서 같이 풀어보았습니다.</p>
<center>[13549 숨바꼭질 3]</center>
<p><img src="https://user-images.githubusercontent.com/110437548/228464527-7757d779-4a30-4d69-ae08-8ecdfab87d30.png" alt="image" /></p>
<center>[13913 숨바꼭질 4]</center>
<p><img src="https://user-images.githubusercontent.com/110437548/228464249-0e9a5b4f-ae18-4f0f-8406-e69651f90b61.png" alt="image" /></p>
<hr />
<h2 id="13549-숨바꼭질-3">13549 숨바꼭질 3</h2>
<h3 id="풀이">풀이</h3>
<p>숨바꼭질 3 문제는 숨바꼭질 2 문제와의 차이점이 2*X의 위치로 이동할 때와 X-1 or X+1의 위치로 이동할 때의 시간이 각각 0과 1로 차이가 있다는 점이다.  <br />
그래서 queue에 이동할 위치의 좌표와 depth를 넣어줄 때 2*X의 위치로 이동할 경우에는 cost에 1을 더해주지 않았다.  <br />
알고리즘을 작성할 때, 2*X -&gt; X-1 -&gt; X+1 순서로 작성해줘야 가장 적은 cost를 구할 수 있다.</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//방문할 수 있는 위치인지 확인하고 X-1, X+1 이동시 cost+1, Xx2 이동시 cost를 넣어준다</span>
        <span class="k">if</span> <span class="nf">isVisitedPossible</span><span class="p">(</span><span class="n">num</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">queue</span><span class="o">.</span><span class="nf">pushLast</span><span class="p">((</span><span class="n">num</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">cost</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nf">isVisitedPossible</span><span class="p">(</span><span class="n">num</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">queue</span><span class="o">.</span><span class="nf">pushLast</span><span class="p">((</span><span class="n">num</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">cost</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nf">isVisitedPossible</span><span class="p">(</span><span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">queue</span><span class="o">.</span><span class="nf">pushLast</span><span class="p">((</span><span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">cost</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="p">}</span>
</code></pre></div></div>
<h3 id="코드">코드</h3>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Queue</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">inbox</span><span class="p">:</span> <span class="p">[</span><span class="kt">T</span><span class="p">]</span>
    <span class="k">var</span> <span class="nv">outbox</span><span class="p">:</span> <span class="p">[</span><span class="kt">T</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">var</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">inbox</span><span class="o">.</span><span class="n">count</span> <span class="o">+</span> <span class="n">outbox</span><span class="o">.</span><span class="n">count</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">isEmpty</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">inbox</span><span class="o">.</span><span class="n">isEmpty</span> <span class="o">&amp;&amp;</span> <span class="n">outbox</span><span class="o">.</span><span class="n">isEmpty</span>
    <span class="p">}</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">queue</span><span class="p">:</span> <span class="p">[</span><span class="kt">T</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">inbox</span> <span class="o">=</span> <span class="n">queue</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">pushLast</span><span class="p">(</span><span class="n">_</span> <span class="nv">element</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">inbox</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">pushFirst</span><span class="p">(</span><span class="n">_</span> <span class="nv">element</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">outbox</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">popLast</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">T</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">inbox</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span>
            <span class="n">inbox</span> <span class="o">=</span> <span class="n">outbox</span><span class="o">.</span><span class="nf">reversed</span><span class="p">()</span>
            <span class="n">outbox</span><span class="o">.</span><span class="nf">removeAll</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">inbox</span><span class="o">.</span><span class="nf">popLast</span><span class="p">()</span><span class="o">!</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">popFirst</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">T</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">outbox</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span>
            <span class="n">outbox</span> <span class="o">=</span> <span class="n">inbox</span><span class="o">.</span><span class="nf">reversed</span><span class="p">()</span>
            <span class="n">inbox</span><span class="o">.</span><span class="nf">removeAll</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">outbox</span><span class="o">.</span><span class="nf">popLast</span><span class="p">()</span><span class="o">!</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">input</span> <span class="o">=</span> <span class="nf">readLine</span><span class="p">()</span><span class="o">!.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">" "</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="kt">Int</span><span class="p">(</span><span class="kt">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">))</span><span class="o">!</span><span class="p">}</span>
<span class="k">let</span> <span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="nv">K</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">input</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="k">var</span> <span class="nv">visited</span> <span class="o">=</span> <span class="kt">Array</span><span class="p">(</span><span class="nv">repeating</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="mi">100001</span><span class="p">)</span>

<span class="c1">//방문하지 않았고, 순간이동할 수 있는 위치인지 확인</span>
<span class="kd">func</span> <span class="nf">isVisitedPossible</span><span class="p">(</span><span class="n">_</span> <span class="nv">x</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="mi">0</span><span class="o">...</span><span class="mi">100000</span><span class="p">)</span> <span class="o">~=</span> <span class="n">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">findSister</span><span class="p">(</span><span class="n">_</span> <span class="nv">startX</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 수빈이 위치 queue에 넣고 visited true로 초기화.</span>
    <span class="k">let</span> <span class="nv">queue</span> <span class="o">=</span> <span class="kt">Queue</span><span class="p">([(</span><span class="n">startX</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">startX</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span>
    
    <span class="c1">//queue가 비었을 때까지</span>
    <span class="k">while</span> <span class="o">!</span><span class="n">queue</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="nv">num</span><span class="p">,</span> <span class="nv">cost</span><span class="p">)</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="nf">popFirst</span><span class="p">()</span>
        <span class="c1">// 큐에서 pop할 때 방문처리</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span>
        
        <span class="c1">// 동생을 찾은 경우 cost 출력</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="kt">K</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
        
        <span class="c1">//방문할 수 있는 위치인지 확인하고 X-1, X+1 이동시 cost+1, Xx2 이동시 cost를 넣어준다</span>
        <span class="k">if</span> <span class="nf">isVisitedPossible</span><span class="p">(</span><span class="n">num</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">queue</span><span class="o">.</span><span class="nf">pushLast</span><span class="p">((</span><span class="n">num</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">cost</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nf">isVisitedPossible</span><span class="p">(</span><span class="n">num</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">queue</span><span class="o">.</span><span class="nf">pushLast</span><span class="p">((</span><span class="n">num</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">cost</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nf">isVisitedPossible</span><span class="p">(</span><span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">queue</span><span class="o">.</span><span class="nf">pushLast</span><span class="p">((</span><span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">cost</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nf">findSister</span><span class="p">(</span><span class="kt">N</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="13913-숨바꼭질-4">13913 숨바꼭질 4</h2>
<h3 id="풀이-1">풀이</h3>
<p>동생을 최소 시간으로 찾을 때의 경로를 나타내야 하므로 <code class="language-plaintext highlighter-rouge">prev</code>라는 배열에 자신의 이전 depth의 값을 넣어줘서 기억한 후  <br />
queue에서 pop한 값이 동생의 위치일 경우 그 경로를 출력해준다.</p>

<h3 id="코드-1">코드</h3>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Queue</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">inbox</span><span class="p">:</span> <span class="p">[</span><span class="kt">T</span><span class="p">]</span>
    <span class="k">var</span> <span class="nv">outbox</span><span class="p">:</span> <span class="p">[</span><span class="kt">T</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">var</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">inbox</span><span class="o">.</span><span class="n">count</span> <span class="o">+</span> <span class="n">outbox</span><span class="o">.</span><span class="n">count</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">isEmpty</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">inbox</span><span class="o">.</span><span class="n">isEmpty</span> <span class="o">&amp;&amp;</span> <span class="n">outbox</span><span class="o">.</span><span class="n">isEmpty</span>
    <span class="p">}</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">queue</span><span class="p">:</span> <span class="p">[</span><span class="kt">T</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">inbox</span> <span class="o">=</span> <span class="n">queue</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">pushLast</span><span class="p">(</span><span class="n">_</span> <span class="nv">element</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">inbox</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">pushFirst</span><span class="p">(</span><span class="n">_</span> <span class="nv">element</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">outbox</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">popLast</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">T</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">inbox</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span>
            <span class="n">inbox</span> <span class="o">=</span> <span class="n">outbox</span><span class="o">.</span><span class="nf">reversed</span><span class="p">()</span>
            <span class="n">outbox</span><span class="o">.</span><span class="nf">removeAll</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">inbox</span><span class="o">.</span><span class="nf">popLast</span><span class="p">()</span><span class="o">!</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">popFirst</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">T</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">outbox</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span>
            <span class="n">outbox</span> <span class="o">=</span> <span class="n">inbox</span><span class="o">.</span><span class="nf">reversed</span><span class="p">()</span>
            <span class="n">inbox</span><span class="o">.</span><span class="nf">removeAll</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">outbox</span><span class="o">.</span><span class="nf">popLast</span><span class="p">()</span><span class="o">!</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">input</span> <span class="o">=</span> <span class="nf">readLine</span><span class="p">()</span><span class="o">!.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">" "</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="kt">Int</span><span class="p">(</span><span class="kt">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">))</span><span class="o">!</span><span class="p">}</span>
<span class="k">let</span> <span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="nv">K</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">input</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="k">var</span> <span class="nv">visited</span> <span class="o">=</span> <span class="kt">Array</span><span class="p">(</span><span class="nv">repeating</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="mi">100001</span><span class="p">)</span>
<span class="k">var</span> <span class="nv">prev</span> <span class="o">=</span> <span class="kt">Array</span><span class="p">(</span><span class="nv">repeating</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="mi">100001</span><span class="p">)</span>
<span class="k">var</span> <span class="nv">count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">var</span> <span class="nv">minDepth</span> <span class="o">=</span> <span class="mi">100001</span>

<span class="c1">//방문하지 않았고, 순간이동할 수 있는 위치인지 확인</span>
<span class="kd">func</span> <span class="nf">isVisitedPossible</span><span class="p">(</span><span class="n">_</span> <span class="nv">x</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="mi">0</span><span class="o">...</span><span class="mi">100000</span><span class="p">)</span> <span class="o">~=</span> <span class="n">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">printPath</span><span class="p">(</span><span class="n">_</span> <span class="nv">num</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">tmp</span> <span class="o">=</span> <span class="n">num</span>
    <span class="k">var</span> <span class="nv">tempArray</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="kt">N</span> <span class="p">{</span>
        <span class="n">tempArray</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">prev</span><span class="p">[</span><span class="n">tmp</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="n">tempArray</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="kt">N</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">tempArray</span><span class="o">.</span><span class="nf">reversed</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nv">terminator</span><span class="p">:</span> <span class="s">" "</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">findSister</span><span class="p">(</span><span class="n">_</span> <span class="nv">startX</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kt">N</span> <span class="o">==</span> <span class="kt">K</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="kt">N</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="nv">queue</span> <span class="o">=</span> <span class="kt">Queue</span><span class="p">([(</span><span class="n">startX</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
    <span class="k">while</span> <span class="o">!</span><span class="n">queue</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span>
        <span class="k">var</span> <span class="p">(</span><span class="nv">num</span><span class="p">,</span> <span class="nv">depth</span><span class="p">)</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="nf">popFirst</span><span class="p">()</span>  
        <span class="k">for</span> <span class="n">next</span> <span class="k">in</span> <span class="p">[</span><span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nf">isVisitedPossible</span><span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span>
                <span class="n">queue</span><span class="o">.</span><span class="nf">pushLast</span><span class="p">((</span><span class="n">next</span><span class="p">,</span><span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">prev</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span>
                <span class="k">if</span> <span class="n">next</span> <span class="o">==</span> <span class="kt">K</span> <span class="p">{</span>
                    <span class="nf">print</span><span class="p">(</span><span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                    <span class="nf">printPath</span><span class="p">(</span><span class="n">next</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">findSister</span><span class="p">(</span><span class="kt">N</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>Lee su-min</name></author><category term="Algorithm" /><category term="백준" /><category term="문제풀이" /><category term="알고리즘" /><category term="그래프 이론" /><category term="그래프 탐색" /><category term="너비 우선 탐색" /><category term="깊이 우선 탐색" /><category term="다익스트라" /><summary type="html"><![CDATA[문제 정보 문제 출처: 백준 온라인 저지 문제 링크: 13549 숨바꼭질 3 13913 숨바꼭질 4 제출 언어: Swift 알고리즘 분류: 그래프 이론 그래프 탐색 너비 우선 탐색 다익스트라]]></summary></entry><entry><title type="html">[Swift] 프로퍼티</title><link href="https://hanabzu.github.io/jekyll-theme-yat/2023/03/28/Swift-Property" rel="alternate" type="text/html" title="[Swift] 프로퍼티" /><published>2023-03-28T00:00:00+00:00</published><updated>2023-03-28T00:00:00+00:00</updated><id>https://hanabzu.github.io/jekyll-theme-yat/2023/03/28/Swift-Property</id><content type="html" xml:base="https://hanabzu.github.io/jekyll-theme-yat/2023/03/28/Swift-Property"><![CDATA[<h2 id="속성과-메서드">속성과 메서드</h2>

<p>구조체와 클래스에는 속성(프로퍼티)와 메서드가 존재한다</p>

<p>속성은 두 타입에서 동일! 메서드에서는 약간의 차이가 있음</p>

<aside>
&gt; 💡 속성 : 구조체/클래스의 변수

</aside>

<ul>
  <li>저장 속성
    <ul>
      <li>지연 속성</li>
    </ul>
  </li>
  <li>계산 속성</li>
  <li>타입 속성
    <ul>
      <li>타입 저장 속성</li>
      <li>타입 계산 속성</li>
    </ul>
  </li>
  <li>속성 감시자 등</li>
</ul>

<aside>
💡 메서드 : 구조체/클래스의 함수

</aside>

<ul>
  <li>인스턴스 메서드</li>
  <li>타입 메서드</li>
  <li>서브스크립트</li>
  <li>생성자</li>
  <li>소멸자</li>
</ul>

<h3 id="1-저장-속성stored-properties">1. 저장 속성(Stored Properties)</h3>

<ul>
  <li>클래스/구조체에서 찍어낸 각 인스턴스가 가지는 고유의 데이터</li>
  <li>var/let으로 선언가능</li>
  <li><code class="language-plaintext highlighter-rouge">객체 초기화를 마치는 경우, 저장 속성은 반드시 값을 가져아함</code> (기본값 &amp; 생성자 &amp; 옵셔널 타입)</li>
  <li>열거형은 따로 메모리 공간이 필요한 저장 속성은 선언 불가능</li>
  <li>저장 속성은 각 속성 자체가 고유의 메모리 공간을 갖는다</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Person</span> <span class="p">{</span>

	<span class="c1">//저장 속성!</span>
	<span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
	<span class="k">var</span> <span class="nv">age</span><span class="p">:</span> <span class="kt">Int</span>

	<span class="kd">func</span> <span class="nf">sit</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">print</span><span class="p">(</span><span class="s">"앉는다"</span><span class="p">)</span>
	<span class="p">}</span>
</code></pre></div></div>

<h3 id="1-1-지연-저장-속성lazy-stored-properties">1-1. 지연 저장 속성(Lazy Stored properties)</h3>

<ul>
  <li>게으른 저장 속성으로 처음부터 값을 초기화하지 않고 지연시킴</li>
  <li>해당 속성이 반드시 처음부터 초기화가 필요하지 않은 경우 (이미지 등 메모리 공간을 많이 차지하는 속성에서 주로 사용)</li>
  <li>값에 대한 접근이 있어야 메모리 공간을 생성하여 초기화시킨다</li>
  <li>lazy var로만 선언 가능(lazy let 불가능)</li>
  <li>
    <p>초기화를 지연시키기 때문에 반드시 기본값이 필요(기본값에  함수 실행문, 계산식, 클로저 실행문 들어갈 수 있음)</p>
  </li>
  <li>지연 저장 속성 사용하는 이유?
    <ul>
      <li>메모리 공간 낭비와 불필요한 성능저하를 줄인다 → 메모리 공간을 많이 차지하는 이미지와 같은 속성들 다룰</li>
      <li>다른 저장 속성을 이용하여 선언해야 할 경우</li>
    </ul>
  </li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Person</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
    <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">age</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">20</span>

		<span class="c1">//컴파일 에러 </span>
    <span class="k">var</span> <span class="nv">nameCount</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">count</span>

		<span class="c1">//다른 저장 속성을 이용하여 선언해야 할 경우 lazy 사용</span>
    <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">nameCount</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">name</span><span class="o">.</span><span class="n">count</span>
		<span class="p">}()</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">p1</span> <span class="o">=</span> <span class="kt">Person</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"soom"</span><span class="p">)</span>

<span class="c1">//해당 변수에 접근하는 시점에서 초기화된다! (메모리 공간 생성)</span>
<span class="c1">//접근 이후에는 계속 메모리 공간에 남아있음</span>
<span class="k">var</span> <span class="nv">age</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">age</span>
<span class="n">p1</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="mi">22</span>

<span class="kd">struct</span> <span class="kt">View</span> <span class="p">{</span>
	<span class="k">var</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span>
	<span class="c1">//해당 속성이 메모리를 많이 차지할 경우 늦게 메모리에 올리기 위해 사용한다</span>
	<span class="kd">lazy</span> <span class="k">var</span> <span class="nv">view</span> <span class="o">=</span> <span class="kt">UIImageView</span><span class="p">()</span>

	<span class="c1">//다른 속성을 이용하여할 때</span>
	<span class="kd">lazy</span> <span class="k">var</span> <span class="nv">b</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="mi">10</span>
	<span class="p">}()</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="2-계산-속성computed-properties">2. 계산 속성(Computed Properties)</h3>

<ul>
  <li>실질적으로 메서드 역할을 하는 속성임</li>
  <li>다른 저장 속성에 의존한 결과로 나옴</li>
  <li><code class="language-plaintext highlighter-rouge">인스턴스에 메모리 공간이 할당되지 않음</code> → 실질적으로 메서드!</li>
  <li>var로만 선언 가능 &amp; 자료형까지 선언</li>
  <li>get 블록 : 해당 인스턴스의 값을 얻는다
    <ul>
      <li>필수구현</li>
      <li>get 블록만 선언시 읽기 전용 (Read-Only)</li>
      <li>읽기 전용의 프로퍼티 선언시 get블록 생략 가능</li>
    </ul>
  </li>
  <li>set 블록 : 밖에서 해당 인스턴스에 접근하여 값을 세팅한다
    <ul>
      <li>기본 파라미터 newValue가 제공됨 (파라미터 이름 설정도 가능)</li>
    </ul>
  </li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Person</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"사람"</span>
    <span class="k">var</span> <span class="nv">height</span><span class="p">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">160.0</span>
    <span class="k">var</span> <span class="nv">weight</span><span class="p">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">60.0</span>
    
		<span class="c1">//다른 속성의 저장 속상을 계산해서 나오는 방식의 메서드를 계산 속성으로 바꿀 수 있다!</span>
    <span class="kd">func</span> <span class="nf">calculateBMI</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Double</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">bmi</span> <span class="o">=</span> <span class="n">weight</span> <span class="o">/</span> <span class="p">(</span><span class="n">height</span> <span class="o">*</span> <span class="n">height</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10000</span>
        <span class="k">return</span> <span class="n">bmi</span>
    <span class="p">}</span>
		
		<span class="k">var</span> <span class="nv">bmi</span><span class="p">:</span> <span class="kt">Double</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>                                               
            <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="n">weight</span> <span class="o">/</span> <span class="p">(</span><span class="n">height</span> <span class="o">*</span> <span class="n">height</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10000</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="p">}</span>
    <span class="p">}</span>
		<span class="c1">//get 블록 생략 가능</span>
		<span class="k">var</span> <span class="nv">bmi</span><span class="p">:</span> <span class="kt">Double</span> <span class="p">{</span>
		      <span class="k">let</span> <span class="nv">bmi</span> <span class="o">=</span> <span class="n">weight</span> <span class="o">/</span> <span class="p">(</span><span class="n">height</span> <span class="o">*</span> <span class="n">height</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10000</span>
		      <span class="k">return</span> <span class="n">bmi</span>
		  <span class="p">}</span>
		
		<span class="k">var</span> <span class="nv">bmi</span><span class="p">:</span> <span class="kt">Double</span> <span class="p">{</span>
		        <span class="k">get</span> <span class="p">{</span>       
		            <span class="k">let</span> <span class="nv">bmi</span> <span class="o">=</span> <span class="n">weight</span> <span class="o">/</span> <span class="p">(</span><span class="n">height</span> <span class="o">*</span> <span class="n">height</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10000</span>
		            <span class="k">return</span> <span class="n">bmi</span>
		        <span class="p">}</span>
		        <span class="nf">set</span><span class="p">(</span><span class="n">bmi</span><span class="p">)</span> <span class="p">{</span>  
		            <span class="n">weight</span> <span class="o">=</span> <span class="n">bmi</span> <span class="o">*</span> <span class="n">height</span> <span class="o">*</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">10000</span>
		        <span class="p">}</span>
		<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>메서드 대신 계산 속성 사용시 장점
    <ul>
      <li>관련이 있는 두가지 메서드(함수)를 한번에 구현할 수 있다</li>
      <li>외부에서 보기에 속성이름을 설정가능하므로 보다 명확해보인다</li>
      <li>계산 속성은 메서드를 개발자들이 보다 읽기 쉽고, 명확하게 쓸 수 있는 형태인 속성으로 변환해놓은 것이다.</li>
    </ul>
  </li>
</ul>

<h3 id="2-1--계산-프로퍼티의-메모리-동작-구조-클래스-기준">2-1)  계산 프로퍼티의 메모리 동작 구조 (클래스 기준)</h3>

<p>메모리 공간을 가지지 않는다</p>

<aside>
&gt; 1. 코드에서 계산 프로퍼티 실행문을 만나면 (p1.bmi)
  2. 힙에 있는 인스턴스로 가고 인스턴스가 가리키고 있는 데이터 영역의 클래스 선언문을 본다
  3. 클래스 선언문의 get블록, set블록 계산 프로퍼티의 메모리 주소를 찾아가서 그 코드를 실행한다
  4. 함수의 실행이므로 스택에 쌓인다
  5. 다루고 있는 인스턴스의 메모리 주소가 get, set 함수의 파라미터 (그 내부 프로퍼티 사용 가능)로 넘겨진다

</aside>
<p>(항상 메서드의 실행은 스택 프레임에서 실행된다)</p>

<ul>
  <li>구조체의 경우 실제로는 함수 메모리 주소 직접 접근</li>
</ul>

<h3 id="3-계산속성-vs-지연저장속성">3. 계산속성 vs 지연저장속성</h3>

<p>지연저장속성은 접근 이후 메모리에 계속 남아있기 때문에 메모리가 큰 프로퍼티 다룰 때 사용한다.</p>

<p>지연저장속성은 한번 접근해서 그 값을 초기화하면 그 값이 계속 유지된다</p>

<p>반면에, 계산속성은 접근 시마다 연산을 하기 때문에 계속 값이 변한다</p>]]></content><author><name>Lee su-min</name></author><category term="Swift" /><category term="Swift" /><category term="Property" /><category term="Value Property" /><category term="Reference Property" /><summary type="html"><![CDATA[속성과 메서드]]></summary></entry></feed>